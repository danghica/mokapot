#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{amssymb,stmaryrd}
\usepackage{bussproofs}
\usepackage[figure]{hypcap}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
fix-cm
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_author "Alex Smith"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 3
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref page
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
Introduction
\end_layout

\begin_layout Standard
[discussion of related work and any relevant background, as usual for reports;
 there's no reason to change the standard structure here]
\end_layout

\begin_layout Section
Overview of Mokapot
\end_layout

\begin_layout Standard
Mokapot is a runtime for Java that attempts to preserve the semantics of
 a Java program while allowing it to run across multiple Java Virtual Machines
 (JVMs), typically hosted on different computers.
 Mokapot is implemented as a program that runs in the normal Java Runtime
 Environment alongside the user's program; most of the time the user's program
 runs untouched, but when it needs to do something that might require communicat
ion with a different JVM, Mokapot takes over and fills in for that part
 of the program.
\end_layout

\begin_layout Subsection
Handling method calls
\end_layout

\begin_layout Standard
The most obvious job that Mokapot needs to handle is forwarding calls to
 methods (the main units of code reuse in Java, equivalent to a function
 or subroutine); sometimes, a method call will be made on one machine, but
 refer to an object on a different machine.
 In Java, most methods are 
\begin_inset Quotes eld
\end_inset

instance methods
\begin_inset Quotes erd
\end_inset

 which pertain to one specific object (called 
\family typewriter
this
\family default
); they can access private state of 
\family typewriter
this
\family default
 by directly inspecting memory, but only non-private information about other
 objects.
 Mokapot does not (and cannot) intercept accesses to private state, and
 thus an instance method must be run on the same machine as 
\family typewriter
this
\family default
.
 As such, if a method is 
\begin_inset Quotes eld
\end_inset

invoked on
\begin_inset Quotes erd
\end_inset

 (i.e.
\begin_inset space \space{}
\end_inset

called with 
\family typewriter
this
\family default
 as) an object that is hosted on another JVM, the flow of program execution
 must be transferred from one JVM to another.
\end_layout

\begin_layout Standard
There are two main aspects to this transfer of control.
 One is intercepting the method call in the first place.
 This is handled via noting that a method cannot be called on an object
 without a reference to it, and Java references cannot directly reference
 objects on other JVMs anyway, so any reference to an object on a different
 JVM must actually go to a dummy object created by Mokapot itself.
 Java supports virtual dispatch, i.e.
\begin_inset space \space{}
\end_inset

changing the code implementing a method based on what object is used as
 its 
\family typewriter
this
\family default
, so this can be handled via using a 
\emph on
proxy
\emph default
 object for which every method is implemented as a call into Mokapot's method-fo
rwarding code.
\end_layout

\begin_layout Standard
The other main aspect is to actually transfer the method call from one JVM
 to another; in particular, handling the arguments to and return value from
 the method.
 Java is a call-( and return-)by value language; primitive types are sent
 by value and returned by value.
 So for primitives, the value of the primitive is serialized and sent over
 the network.
 For objects, a reference to the object is treated as a value in its own
 right (Java 
\begin_inset Quotes eld
\end_inset

sends references by value
\begin_inset Quotes erd
\end_inset

), meaning that the object can be modified via the sent reference.
 Mokapot will normally try to replicate this, sending a unique identifier
 for the object and information about how to determine its location; if
 the object happens to be located on the recipient, the copy of Mokapot
 on the recipient JVM will simply replace it with a reference to the actual
 object, otherwise it will create a proxy object on the recipient and provide
 a reference to that.
\end_layout

\begin_layout Standard
However, 
\begin_inset Quotes eld
\end_inset

reference-by-value
\begin_inset Quotes erd
\end_inset

 passing is in many cases inefficient, as it effectively serializes a computatio
n across all the JVMs involved in it; any mention of a given object will
 cause program control to pass onto the JVM that hosts it so that its private
 state can be accessed.
 Copying a Java object, and replacing a reference to the object with a reference
 to the copy, in general changes the semantics of a Java program, and thus
 is not a correct optimization in general.
 However, in practice, many algorithms will treat copies of objects as interchan
geable with each other, and for many classes of object, a copy of the object
 is indistinguishable from the original (except via use of built-ins that
 specifically check for an object's identity).
 Mokapot therefore supports the concept of a 
\emph on
copiable
\emph default
 object – an object for which some references to that object can safely
 be replaced by references to a copy of that object without changing the
 semantics of the program – and treats copiable objects specially in many
 places.
 For example, if a copiable object is used as an argument to or return value
 from a method call, instead of sending it as an ID number and location,
 Mokapot will take a copy of all the object's private state, together with
 sufficient information to regenerate the object's 
\emph on
vtable
\emph default
 (a table of which code is used to implement each of the object's methods),
 and send that instead.
 The copy of Mokapot on the recipient JVM will then use that information
 to create a copy of the original object, and use that.
\end_layout

\begin_layout Subsection
Other jobs performed by Mokapot
\end_layout

\begin_layout Standard
Although Mokapot's main functionality is to forward method calls from one
 JVM to another, creating proxy objects as it goes, a number of more minor
 functionalities are also required in order to create a complete program.
\end_layout

\begin_layout Standard
One of the most important is to be able to start a distributed computation
 in the first place.
 Although the algorithm in the previous section is 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 in the sense that it will preserve the semantics of a Java program, if
 it starts from a state where no object on a JVM has a reference to any
 JVM outside it, that state will persist indefinitely, and only a single
 JVM will actually be used.
 Normally, a program that benefits from distributed computing would be concurren
t (so that it can run some of its threads on one JVM, and some on another
 on a different computer, to make full use of both computers' CPUs); but
 unless the program is 
\begin_inset Quotes eld
\end_inset

embarrassingly parallel
\begin_inset Quotes erd
\end_inset

, there will need to be some interaction between the two JVMs, and thus
 some references crossing from one to the other.
\end_layout

\begin_layout Standard
In order to get a computation started, therefore, Mokapot provides a method
 that allows code to be run explicitly on a particular JVM.
 This code needs to be copiable and to return a value without taking arguments
 (in Java terms, this latter condition is known as a 
\begin_inset Quotes eld
\end_inset

supplier
\begin_inset Quotes erd
\end_inset

, thus this is a 
\family typewriter
CopiableSupplier
\family default
); Mokapot implements this method via copying the supplier onto the JVM
 in question and using it to supply a return value.
 If the code returns a noncopiable object, the object itself will be left
 on the JVM in question, and a reference to it will be returned across the
 network, and this thus serves as a means to create the first cross-JVM
 reference and make a distributed computation possible.
\end_layout

\begin_layout Standard
Another important job is that of garbage collection.
 Java's garbage collector can only work within a single JVM, so Mokapot
 needs to take over in order to ensure that objects involved in cross-JVM
 references are not freed too early or late; in particular, it needs to
 act as a garbage collection root for objects that are referenced from a
 remote JVM, but to ensure that the objects are dropped when they are no
 longer referenced either locally or remotely.
 Apart from communication to implement method calls, which is done in response
 to actions by the user's program (and is effectively part of its call stack),
 the vast majority of network communication originated by Mokapot 
\begin_inset Quotes eld
\end_inset

outside
\begin_inset Quotes erd
\end_inset

 the normal control flow of the user's program is garbage collection metadata,
 used to signify that an object is still allocated or is no longer allocated,
 or to ask the remote JVM to check whether an object is still referenced.
\end_layout

\begin_layout Standard
Mokapot's garbage collection routine works via a 
\begin_inset Quotes eld
\end_inset

garbage collection weight
\begin_inset Quotes erd
\end_inset

 algorithm that has similar properties to a reference-counting algorithm;
 in particular, it cannot detect cycles of references that cross between
 one JVM and another.
 As such, Mokapot contains a special case for handling objects, or interconnecte
d groups of objects, that are not locally referenced: they are moved onto
 some other JVM that references them, known as 
\emph on
automatic migration
\emph default
.
 This is a performance optimization, in that remote method calls are much
 more expensive than the JVM's normal mechanisms for calling methods locally;
 but it's also done for correctness, in that a reference cycle with no reference
s from outside will eventually end up migrating onto a single JVM, at which
 point it will no longer contain a cross-JVM reference (meaning that the
 garbage collection algorithm will be able to detect it and deallocate the
 entire cycle).
 In addition to automatic migration, manual migration is also supported,
 allowing the user to move objects between JVMs at runtime to dynamically
 tune their algorithms.
\end_layout

\begin_layout Subsection
Non-functional requirements
\end_layout

\begin_layout Standard
In addition to preserving the semantics of the user's Java program while
 running it on multiple JVMs at the same time, Mokapot also contains code
 to handle a number of less obvious requirements.
\end_layout

\begin_layout Standard
One of the most important is security.
 Mokapot is, in essence, a program that accepts network connections and
 then runs arbitrary code based on the content received, and thus it is
 important to only accept commands from authorized users.
 Two levels of defense against attackers are used.
 The first is an authorized and authenticated perimeter; a set of JVMs as
 a whole has a private key, and each individual JVM involved in the computation
 has its own separate private key (with the corresponding public key signed
 by the private key for the whole set) and knows the public key for the
 whole set.
 This enables all communication used to be signed; each JVM sends its own
 public key along with the communication, and the recipient can verify that
 the public key belongs to the set of JVMs and was used to sign the message.
 Any messages that don't use an appropriate key are ignored.
 (Because Transport Level Security (TLS) is used to implement the authorization,
 the communication is also encrypted to prevent eavesdropping, a feature
 that TLS provides for free.)
\end_layout

\begin_layout Standard
The other layer of defense against attackers comes from Java's own security
 infrastructure.
 Mokapot is careful to distinguish between things it does itself (e.g.
\begin_inset space \space{}
\end_inset

creating proxy objects), and things that the user's code is doing (e.g.
\begin_inset space \space{}
\end_inset

calling methods), and aims to preserve an appropriate security context for
 each; this means that Mokapot can be authorized to do things, like looking
 at the private state of a standard library object, without giving the same
 authorization to the code it is being used to run.
 This in turn makes it possible to sandbox the user's code to prevent it
 performing operations that it would not be expected to perform, according
 to the principle of least privilege.
\end_layout

\begin_layout Standard
Mokapot also provides tools for supporting efficiency.
 Although most of what Mokapot does can be implemented at runtime, using
 Java's 
\begin_inset Quotes eld
\end_inset

reflection
\begin_inset Quotes erd
\end_inset

 APIs for introspection into the objects it is dealing with, it is more
 efficient to use code specialized to the individual classes of object that
 the user program uses.
 Thus, Mokapot can cooperate with an ahead-of-time compiler that generates
 efficient serialization code, proxy objects with fewer levels of indirection,
 and the like.
 Even when the ahead-of-time compiler is not available, or is not used,
 Mokapot will attempt to do the same code generation at runtime, falling
 back to reflection only in cases where the code generation is not useful
 or not possible.
\end_layout

\begin_layout Standard
Finally, Mokapot is of course somewhat concerned with communication; the
 specification for Mokapot basically thinks of JVMs as existing in the abstract,
 but of course any given computation will need some concrete set of JVMs
 and some concrete means for communicating between them.
 Mokapot implements a 
\begin_inset Quotes eld
\end_inset

communicator
\begin_inset Quotes erd
\end_inset

 as an I/O layer that abstracts away the details of communication from the
 rest of Mokapot (and also serves as a main entry point for user programs
 to make requests of Mokapot directly, and somewhere to store all the internal
 state of the computation).
 The communicator is responsible for listening for connections from other
 communicators: JVMs can be added to and removed from a computation 
\begin_inset Quotes eld
\end_inset

live
\begin_inset Quotes erd
\end_inset

 while it's ongoing, and thus communicators do not maintain any more global
 state than they have to (being unaware of other communicators except when
 a reference exists from an object on one JVM to another, which causes the
 respective communicators to become aware of each other).
 Thus, the network topology is not static either, with links being formed
 and broken as required by the computation.
 The other parts of Mokapot think not in terms of network connections, but
 in terms of individual messages that are sent in a delay-insensitive manner
 (i.e.
\begin_inset space \space{}
\end_inset

no guarantees about whether they arrive in the same order as they were sent),
 meaning that the communicator can abstract away the details of sending
 messages, connecting to JVMs that were not previously part of the computation,
 reconnecting after a connection breaks, and so on.
 The communicator is also responsible for ensuring an orderly shutdown when
 a JVM is removed from the computation, ensuring that no state that might
 be required by other JVMs is stored there.
\end_layout

\begin_layout Part
Mokapot in an ideal world
\end_layout

\begin_layout Section
Copiable objects
\end_layout

\begin_layout Standard
One of the main issues in implementing object-oriented languages is that
 many such languages use the concept of the 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

 as a single umbrella concept that covers all, or almost all, of the data
 stored in a program execution.
 This level of generality comes at its usual cost, of forcing the implementation
 of the objects to have a similar level of generality, even though objects
 may well fall into special cases that consequently benefit from special
 treatment.
 As such, to have much of a chance to be efficient, Mokapot needs to carry
 out some static analysis on the user's program in order to determine what
 objects are suited for this type of special treatment.
\end_layout

\begin_layout Standard
In this part of the report, we generally disregard the differences between
 Java and a hypothetical 
\begin_inset Quotes eld
\end_inset

ideal Java-like object-oriented programming language
\begin_inset Quotes erd
\end_inset

; these issues will be explored later in the report.
 So from the point of view of this section, this sort of analysis is purely
 an optimization (although a fairly large one).
 However, it turns out that in actual Java this sort of analysis is necessary
 for correctness, too; there are some special cases in Java that can't be
 implemented correctly if treated in a general way, but can be correctly
 implemented as special cases.
 It is therefore necessary to carry out at least some analysis of the program
 being run.
\end_layout

\begin_layout Standard
Mokapot's static analysis of a program proceeds at the class-by-class level,
 and is fairly coarse-grained; each class is sorted into one of a few different
 groups by checking them for certain properties.
 (This checking is done in a 
\begin_inset Quotes eld
\end_inset

by need
\begin_inset Quotes erd
\end_inset

 way; a class is analyzed the first time the information is needed, and
 then this is remembered for future objects of the same class; a Java program
 can contain only finitely many classes, thus this gives only a constant
 amount of overhead for any given program, even if the checking is quite
 slow.) The most important of these properties is 
\emph on
copiability
\emph default
; by examining its class, every object is declared to be either 
\emph on
noncopiable
\emph default
 (the general case), or 
\emph on
copiable
\emph default
 (a special case, but a very important one).
\end_layout

\begin_layout Subsection
Objects with no identity
\end_layout

\begin_layout Standard
Copiability is, in a sense, a statement about what a Java object 
\emph on
is
\emph default
.
 In Java, objects are used for everything, and thus highly general, containing
 several different pieces of information: most obviously, a class (which
 determines which methods they have), and normally fields (used to store
 data).
 Java objects also contain some more obscure information, including a 
\emph on
monitor
\emph default
 (a lock with attached condition variable), and a finalization flag that
 prevents an object resurrected during garbage collection from being finalized
 a second time.
 However, one of the most important pieces of information about an object
 is arguably not part of it at all; Java calls this the object's 
\emph on
identity
\emph default
, and it's what distinguishes the object from other similar objects (it
 can be thought of as the value that's stored by a reference to that object;
 in some related languages, like C++, the equivalent of an object identity
 is the object's address in memory).
 Whenever an object is created, it has an identity distinct from that of
 any other object, and object identities cannot be changed; distinct objects
 thus always have distinct identities (and this enables two otherwise identical
 objects to be distinguished from each other).
 For example, Java objects can be stateful, allowing their fields to be
 assigned to; even if two objects have the same field values as each other,
 writing to a field of one will not write to a field of the other, and that's
 because the object identity is used to specify which object's fields should
 be changed.
 However, even though all objects 
\emph on
have
\emph default
 an identity, not all objects 
\emph on
need
\emph default
 one; it is quite common for objects to be used to represent a class plus
 a particular set of field values, without the object needing a particular
 existence in its own right.
 A copiable object, therefore, is in essence an object whose identity is
 irrelevant, and never used.
\end_layout

\begin_layout Standard
The notion of copiability thus comes with some fairly major restrictions
 on what can be done with the object.
 If it's possible to assign to an object's fields, it isn't copiable (because
 the assignment only affects one object, not copies of it).
 Likewise, any changes to the object's monitor would in theory render it
 noncopiable, and of course any operations that operate on the object's
 identity directly (most notably 
\family typewriter
==
\family default
, which compares two objects' identities for equality) will prevent copiability.
 That said, copiable objects are nonetheless very common, and the concept
 is increasingly recognized as being an important one even within the Java
 standard library and its documentation; in Java 8, the concept of a 
\begin_inset Quotes eld
\end_inset

value-based class
\begin_inset Quotes erd
\end_inset

 was introduced in the standard library documentation
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html
\end_layout

\end_inset


\end_layout

\end_inset

 (which comprehensively captures the concept of 
\begin_inset Quotes eld
\end_inset

this object's identity is irrelevant
\begin_inset Quotes erd
\end_inset

), and used by classes such as 
\family typewriter
java.time.Instant
\family default
 (a copiable class that acts as a replacement for the noncopiable 
\family typewriter
java.util.Date
\family default
); and at the time of writing, development is currently under way to implement
 the concept of 
\begin_inset Quotes eld
\end_inset

objects with no identity
\begin_inset Quotes erd
\end_inset

 directly into the language itself.[cite 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.oracle.com/a/ocom/docs/corporate/java-magazine-nov-dec-2018.pdf
\end_layout

\end_inset

 page 56]
\end_layout

\begin_layout Standard
If the concept of an identity-less object is ever added to Java as an official
 feature, there will likely be an API to determine whether or not an object
 has an identity.
 However, Mokapot presently needs to work with a version of Java without
 this feature, and will need to be able to work with old Java programs even
 once it's implemented, so at present copiability can only be determined
 via either explicit information to this regard specified manually by a
 human (Mokapot supports a marker interface allowing classes to be marked
 using 
\family typewriter
implements Copiable
\family default
), or else via static analysis.
 However, there is something of an issue here.
 Java programmers normally think in terms of whether an object's identity
 has any semantic meaning; and normally consider an object's class (or at
 least its documentation) to specify how ever part of that object is used
 within the program.
 As such, from the viewpoint of most Java programmers, copiability is effectivel
y a property of the object's class; but the definition of copiability above
 is a set of restrictions on how the object is used, without any mention
 of the object's class, and a little thought shows a potential disconnect.
 Imagine two Java classes, each of which happen to have the same number
 of fields and types of fields (say, both of them contain two 
\family typewriter
boolean
\family default
s as their only fields); the fields have different semantics between the
 two classes, different names, and in general no connection to each other.
 These will be seen by programmers as entirely unrelated, but assuming no
 clashes in methods between the two classes (even in implementations of
 methods like 
\family typewriter
.equals()
\family default
 that all objects must implement), the Java implementation wouldn't care
 if you combined them both into a single class with two sets of methods,
 with each object only using one or the other; the concept of 
\begin_inset Quotes eld
\end_inset

all objects with the same class ascribe the same meaning to the state stored
 within them
\begin_inset Quotes erd
\end_inset

 is in theory just a guideline that exists to make Java easier to program
 in, rather than something that's actually enforced by the language itself.
 The reason this is relevant is that copiability, as defined above, is a
 property of how an object is used, rather than anything in an object's
 definition.
 Thus, it cannot be reliably deduced from a static analysis of an object
 itself, only of all the code that uses it.
\end_layout

\begin_layout Standard
Mokapot, however, mostly disregards this issue, and nonetheless attempts
 to deduce copiability of objects at the class level; a static analysis
 to determine which individual objects are copiable would be very difficult
 (possibly impossible), be incompatible with important Java features such
 as class loading at runtime (implying that the full program being run may
 not exist to be statically analyzed until after a decision about copiability
 already needs to have been made), and be highly unintuitive for programmers
 who might want to specify copiability manually and expect it to be a property
 of the class.
 This means that Mokapot's automatic deduction of copiability necessarily
 needs to be an approximation.
 The heuristic used for this has both false negatives and false positives,
 and works by concentrating entirely on the object's fields.
 If the definition of the class is such that fields of its object would
 be prevented from ever being assigned to as a consequence of Java's type
 system (thus removing any possibility of the object's identity being used
 for its most common purpose, determining which object to mutate), Mokapot
 optimistically assumes that the identities of its objects are not used
 for any other purpose, either.
 (In cases where this is incorrect, the programmer can manually specify
 the class as noncopiable using a marker interface, 
\family typewriter
implements NonCopiable
\family default
.) In cases where an object's fields could be mutated, Mokapot assumes that
 it is not copiable, even if the mutation never actually happens.
 There are a few hardcoded exceptions, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
java.lang.Object
\family default
, the common superclass of all objects, is treated as noncopiable if instantiate
d directly (because the class in question has no functionality of its own,
 thus a direct use of it is highly likely to care about the identity of
 the resulting object as it has no other relevant features).
\end_layout

\begin_layout Subsection
Degrees of copiability and noncopiability
\end_layout

\begin_layout Standard
Mokapot uses a different name, 
\begin_inset Quotes eld
\end_inset

copiability
\begin_inset Quotes erd
\end_inset

, from the names typically used to describe an object whose identity is
 entirely unused (normally some variation on 
\begin_inset Quotes eld
\end_inset

value type
\begin_inset Quotes erd
\end_inset

).
 This is due to the reason Mokapot cares about whether objects are copiable
 or not: in a distributed computation, when there are no issues synchronizing
 the various objects against each other, it is normally more efficient to
 store a copy of an object locally on each JVM involved in the computation,
 than it would be to require network traffic between the various JVMs if
 an object were required by the computation and not stored locally.
 Thus, Mokapot's interest is in whether it can actually make those copies
 without affecting the semantics of the program.
 For noncopiable objects, Mokapot respects its inability to copy the object,
 storing only one copy of the object (thus necessarily localized to only
 a single JVM) and communicating between JVMs as necessary to operate on
 it; but for copiable objects, each JVM that needs to operate on the object
 is given a copy of it the first time it would receive a reference to it.
\end_layout

\begin_layout Standard
Mokapot's motivation for determining copiability is a little different from
 a programmer's (or language designer's) motivation in disregarding an object's
 identity.
 The two concepts are very related, because a copy of an object is the same
 as the original in most respects but has a different identity, and thus
 
\begin_inset Quotes eld
\end_inset

a copy of this object is indistinguishable from the original
\begin_inset Quotes erd
\end_inset

 is a natural consequence of 
\begin_inset Quotes eld
\end_inset

this object's identity is never relevant
\begin_inset Quotes erd
\end_inset

.
 However, Mokapot only cares about whether the actual act of replacing an
 object with a copy will lead to trouble, and thus its exact definition
 of copiability is different from the 
\begin_inset Quotes eld
\end_inset

no identity
\begin_inset Quotes erd
\end_inset

 definition given above.
 In particular, an object can be marked as copiable even if the object's
 identity 
\emph on
is
\emph default
 used by the program, so long as using a separate copy of the object on
 each JVM is safe for other reasons.
 There are three common situations where this occurs.
 The first is the situation in which an object contains a cache or similar
 information that is expensive to compute and might not ever need to be
 computed (and thus, as an optimization, mutates itself to remember the
 result of the calculation); copying the object will not change the semantics
 of this, whether or not the cache is filled at the time (and even if the
 cache is cleared as a result of the copy).
 The second is a common optimization in which the value comparison method
 
\family typewriter
equals
\family default
 checks to see if the compared objects have the same identity (using this
 to short-circuit a more expensive comparison if the identities match, knowing
 that the object will necessarily compare equal to itself); replacing the
 object with a copy will prevent the short-circuiting from happening, but
 will nonetheless give the correct answer (but a little more slowly).
\end_layout

\begin_layout Standard
The third situation is more interesting, and covers the situation in which
 an object is for whatever reason only used or usable once, with attempts
 to use it multiple times being considered bugs in the original program
 (with no defined semantics); after a copy, all but one of the copies will
 thus be entirely unused, and discarded without inspection, so it will be
 as though the object were never copied in the first place.
 These 
\begin_inset Quotes eld
\end_inset

copiable but with relevant identity
\begin_inset Quotes erd
\end_inset

 situations are not automatically inferred, but can be specified manually
 by the programmer.
 There is at least one situation in which Mokapot's own internals have a
 manual copiability specification for this reason: when a message is sent
 across the network, the resulting message (which midway through deserialization
 is a Java object) must only be deserialized once due to containing a supply
 of GC weight (subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:GC-weight"

\end_inset

).
 The deserialization algorithm involves moving a pointer through a buffer
 to remember how much of the message has been deserialized so far, a use
 of the object's identity (this would not update the corresponding pointer
 in a copy), but a cross-JVM copy is still safe because the object is only
 deserialized on one JVM.
 In this case, the copiability annotation is actually required; otherwise,
 deserializing a network message would require sending a network message
 (to update the pointer on a different JVM), leading to an infinite regress.
\end_layout

\begin_layout Standard
Mokapot's 
\begin_inset Quotes eld
\end_inset

copiable
\begin_inset Quotes erd
\end_inset

 notion (and corresponding 
\family typewriter
Copiable
\family default
 marker interface) thus capture the notion of cross-JVM copies being safe.
 A highly related concept is the concept of object 
\emph on
merging
\emph default
 being safe, taking two objects that are identical except for their identities,
 and replacing them with a single object; 
\begin_inset Quotes eld
\end_inset

mergable + copiable
\begin_inset Quotes erd
\end_inset

 captures the notion of an object with no identity more directly than copiabilit
y itself.
 Some experimental versions of Mokapot made use of this concept in order
 to prevent copies of a single object proliferating in memory (by merging
 them all), but this did not seem to be helpful for performance, so the
 notion of mergability is not presently used (nor even implemented) in Mokapot;
 it's thus mostly just useful for clarifying the distinction between a copiable
 object and a true value type.
\end_layout

\begin_layout Standard
There is also a situation in which an object could be considered noncopiable
 even if its identity is completely irrelevant.
 Value types are an important concept for understanding programming in general,
 but from Mokapot's point of view, they're simply an optimization; and an
 optimization is not worthwhile unless it actually makes the program more
 efficient.
 As such, classes (and thus their objects) are considered to be noncopiable
 in situations in which copying them to every JVM is unlikely to actually
 help.
 At present, there are three situations where this can occur.
 One is for situations in which an object of the class could contain, perhaps
 indirectly, a reference to itself or another object with the same class,
 without any noncopiable objects involved in the reference chain.
 The issue here is that the object might be a large recursive structure
 (such as a linked list), and Mokapot's algorithm would naturally copy the
 entire structure even if only a few elements were used, making an 
\begin_inset Formula $\textrm{O}(1)$
\end_inset

 algorithm into an 
\begin_inset Formula $\textrm{O}(n)$
\end_inset

 algorithm, not the sort of behaviour you'd expect from an optimization.
 As a side benefit, this means that the serialization code for copiable
 objects does not need to be able to handle circular structures, making
 it somewhat simpler and faster.
 The second situation is a consequence of differences between the actual
 version of Java and an idealized version of it, which leave some objects
 hard to serialize reliably; classes whose fields are hard to serialize
 are artificially declared as noncopiable to reduce the chance than an unreliabl
e serialization operation would be needed (fields of noncopiable objects
 are much less likely to be serialized than fields of copiable objects).
\end_layout

\begin_layout Standard
The third situation affects both objects which would naturally be copiable,
 and objects which would naturally be noncopiable, and introduces a third
 classification of objects, the 
\emph on
nonmigratable
\emph default
 objects (which are considered a subset of noncopiable objects).
 These are objects which, for whatever reason, must only be allowed to exist
 on a 
\emph on
specific
\emph default
 single JVM (contrast copiable objects, which normally exist on every JVM
 that needs a copy of them, and noncopiable objects, which are stored on
 only one JVM but it does not generally matter which).
 Sometimes a programmer will want to explicitly mark an object as nonmigratable,
 either because the specific location of the object is important for performance
 reasons or so that the programmer can access specific resources like the
 file-system; this can be done by means of marker interface (implements
 
\family typewriter
NonMigratable
\family default
).
 Another reason to mark an object as nonmigratable is for compatibility;
 sometimes, both Mokapot and some other library will want to do something
 particularly low-level to an object (such as hooking into Java's garbage
 collector as it relates to the object), and the particular low-level changes
 the two libraries make are incompatible.
 Mokapot aims to avoid particularly low-level operations on an object which
 is marked as illegal to migrate, in order to provide a mechanism of making
 this case work (for example, it does not attempt to determine whether or
 not the object is locally dead, information which would normally only be
 helpful in migration anyway).
 Nonmigratable objects are treated as noncopiable objects in all respects
 unrelated to migration (a copy would place the copy on a different JVM,
 defeating the point of nonmigratability, so treating them as copiable would
 not work).
\end_layout

\begin_layout Section
Shallow serialization
\end_layout

\begin_layout Standard
It's often necessary for Mokapot to send objects from one JVM to another,
 typically over a network.
 For example, copiable objects are copied from one JVM to another as necessary
 (equivalently, the object is sent without being deleted from the original
 JVM in the process); and even noncopiable objects may need to be migrated
 between JVMs.
 The normal way to transmit objects from one computer to another is to serialize
 them into a sequence of bytes that allows the object to subsequently be
 recreated.
 However, normal serialization algorithms cannot be used for the purpose;
 the issue is that they recursively copy not only the object but everything
 it references, whereas in order to maintain the semantics of the original
 Java program, Mokapot needs to copy just the object itself.
 In other words, Mokapot needs to do a shallow copy rather than a deep copy;
 and this means that it needs a form of serialization that recreates the
 original object on another JVM, but leaves all its references to other
 objects intact.
 This is an operation that wouldn't be possible without Mokapot or a similar
 runtime (because it leaves references from one JVM to another behind),
 and thus was not available in standard libraries or pre-existing packages;
 there was therefore a need to write a new serialization library for Mokapot.
\end_layout

\begin_layout Standard
One important distinction to make here is between serializing to depth 0
 and serializing to depth 1.
 With depth-0 serialization, the serialized form of a noncopiable object
 is a reference to that object; after all, we can't copy the object without
 changing the semantics of the program, so all the references to the object
 need to go to the same place.
 This is used for any form of serialization where the original object might
 need to be retained.
 On the other hand, if we're migrating an object from one JVM to another,
 we can't use a form of serialization that would leave references to the
 object's original location; rather, we have to directly move the object
 between systems.
 That involves, effectively, doing a depth-0 serialization of each of the
 object's fields and sending those (i.e.
\begin_inset space \space{}
\end_inset

a depth-1 serialization of the object itself), which is enough information
 to recreate the object on a different system.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:serialize-class-name"

\end_inset

Serializing object classes
\end_layout

\begin_layout Standard
Whether an object is copiable or noncopiable, serialized to depth 0 or depth
 1 or even making a deep copy, it's important for a deserializing JVM to
 know what class the object belongs to before it can do anything else with
 it.
 The two most important reasons for this are so that it can create an object
 of the appropriate class, and so that it knows whether the object is copiable
 or noncopiable (and thus can choose an appropriate deserialization routine).
 The first part of the serialization of almost any object, therefore, is
 a description of what class the object belongs to.
\end_layout

\begin_layout Standard
Generally speaking, a Java class is represented by a large amount of byte-code,
 stored in a 
\family typewriter
.class
\family default
 file.
 However, sending the entire byte-code for the class each time would have
 two major problems.
 One is the practical problem of bandwidth consumption; almost everything
 we send over the network is objects, and Java classes are typically a few
 kilobytes in size (much larger than the total amount of data stored within
 a typical object), so doing this would greatly increase the amount of network
 traffic required.
 The other is the problem of comparing classes; it is reasonable to ask
 whether two objects belong to the same class (using code like 
\family typewriter
a.getClass().equals(b.getClass())
\family default
), and thus deserializing an object when another object of the same class
 already exists should load it into the pre-existing class.
\end_layout

\begin_layout Standard
One simple and fairly general solution, that Mokapot uses in the majority
 of cases, is to specify the class 
\emph on
name
\emph default
 as the first part of the object's serialization.
 This relies on distinct classes having distinct names, which in practice
 means that the class-path needs to be the same on all JVMs involved in
 the distributed computation.
 It also relies on a JVM being able to locate a class given its name; assuming
 no custom class-loaders are in use, this is true for any class that has
 already been loaded, and for any class that exists on the class-path.
 This technique therefore only fails to apply when serializing objects of
 a class that was generated at runtime, such as lambda classes and proxies.
 Java already has a built-in mechanism for handling this sort of object;
 the object provides a 
\family typewriter
writeReplace
\family default
 method that outputs a description of how to recreate that object (where
 the description is just a Java object of a type that exists at compile
 time); and the description, in turn, provides a 
\family typewriter
readResolve
\family default
 method that constructs a copy of the original object.
 The exact semantics of these methods are not well-specified; the Java documenta
tion specifies when the methods are executed (during serialization and deseriali
zation respectively), and why they are used (to designate an alternative
 object to use for serialization purposes), but does not place constraints
 on the actual functionality of the methods.
 However, the ideal behaviour from Mokapot's point of view would be for
 a 
\family typewriter
writeReplace
\family default
/
\family typewriter
readResolve
\family default
 pair to construct a shallow copy of the original object, and happily, it
 turns out that the ideal behaviour is observed in practice, with the 
\family typewriter
writeReplace
\family default
 method of generated lambda classes creating exactly the sort of description
 that is needed.
\end_layout

\begin_layout Standard
There are, however, performance considerations that suggest a different
 format for the class name in some cases.
 The issue is that a class name can be fairly long (for example, the longest
 class name in Mokapot at present is 
\family typewriter
xyz.acygn.mokapot.DistributedCommunicator$ActiveThreadInfo$
\begin_inset Newline linebreak
\end_inset

LocalThreadShutdownMessage
\family default
, 85 bytes long, and user programs being used with Mokapot might well contain
 classes with similarly long names).
 Trying to determine if the class is already loaded therefore requires a
 string comparison, and all the bytes in the name have to be sent over the
 network.
 In common cases, therefore, it makes sense to use an identifier for a class
 name that's faster to look up.
 When representing strings in serialized data, Mokapot uses length-prefixed
 format (first sending the number of bytes in the string as four bytes,
 then the string itself encoded as UTF-8); to avoid clashes with this format,
 the 
\begin_inset Quotes eld
\end_inset

special case class name descriptions
\begin_inset Quotes erd
\end_inset

 are represented using negative numbers encoded as four bytes (because the
 length of a string cannot be negative).
\end_layout

\begin_layout Standard
There are four sets of classes which have special formats for the descriptions
 of their class name within object metadata, and thus allow the class name
 to be expressed in just four bytes (and avoid an expensive class lookup
 on the receiving JVM).
 First, classes which are very commonly used in Java (such as 
\family typewriter
java.lang.String
\family default
) are given special-case descriptions purely because they're expected to
 be used repeatedly in user code.
 The serialization machinery is not just used to serialize user objects,
 but also Mokapot-internal objects (this avoids the need to invent any special
 format for sending messages over the network – you just send an object
 and call a method of it on the receiving JVM); so all the classes Mokapot
 uses that could be sent over a network, such as 
\family typewriter
xyz.acygn.mokapot.MessageEnvelope
\family default
, are also allocated codes.
 Third, there's an occasional need to send a non-object over the network
 (for example, object fields can have primitives like 
\family typewriter
int
\family default
 as their types, and serialization can send a list of fields); in these
 cases, it's obviously impossible to send the name of the object's class,
 so a set of 
\begin_inset Quotes eld
\end_inset

class name descriptions
\begin_inset Quotes erd
\end_inset

 exists that collectively cover all of Java's non-object data (most notably,
 
\family typewriter
null
\family default
 does not belong to a class, but can be stored in a field that normally
 stores objects).
\end_layout

\begin_layout Standard
The fourth set is more interesting, and implements a more context-based
 optimization; in many cases, a field of an object can be predicted as likely
 to have a particular class, without there being any guarantee that it actually
 has that class.
 For example, if an object field is declared as 
\family typewriter
java.util.ArrayList
\family default
, the actual value of that field might have a different class (for example,
 it could legally be a user-defined class extending 
\family typewriter
ArrayList
\family default
), but it is very likely in practice that the the value's actual and declared
 classes will match.
 Mokapot therefore has class name descriptions that can be used for predictable
 classes; for example, 
\begin_inset Quotes eld
\end_inset

the declared type of the field being deserialized
\begin_inset Quotes erd
\end_inset

 (the meaning of this is modified based on context, e.g.
\begin_inset space \space{}
\end_inset

when we aren't deserializing an object field).
\end_layout

\begin_layout Standard
This fourth set of descriptions is also overloaded somewhat to allow the
 serialization format to represent a specific special case of a circular
 structures (specifically, one in which a 2-element cycle exists between
 two objects), adding a 
\begin_inset Quotes eld
\end_inset

class name description
\begin_inset Quotes erd
\end_inset

 to represent this particular special case; instead of just encoding a somewhat
 predictable class, it's encoding the object as well.
 Upon seeing this, Mokapot's deserializer can just add the reference to
 the object directly.
 Circular structures are normally treated as noncopiable (because copiability
 is based on the class, not the object, and a class that can be used to
 store a circular structure can also be used to store a recursive structure;
 potentially recursive structures are treated as noncopiable because they
 are often very large, and thus circular structures are noncopiable for
 the same reason).
 However, the mechanism exists to permit potentially circular structures
 to be manually overridden to be treated as copiable (most notably, 
\family typewriter
Throwable
\family default
, which is forced to be copiable because trying to remotely access objects
 on a system which may just have thrown a fatal error is considered to be
 too unreliable, and which has had size-2 reference cycles observed in practice).
\end_layout

\begin_layout Standard
There's one final optimization that Mokapot uses to encode classes.
 As mentioned earlier, classes that are somewhat predictable (but with potential
 exceptions) can be encoded in four bytes.
 However, some classes are absolutely predictable, typically because the
 field or variable in which the value needs to be stored is only capable
 of holding values of one specific type.
 (This happens for primitives, which don't support object oriented features;
 and fields which have a 
\family typewriter
final
\family default
 class as their declared type, because the declaration prevents the field
 value's actual type being any less specific than the declared type, and
 the 
\family typewriter
final
\family default
 modifier prevents any value's actual type being more specific than the
 declared type.) In this case, there's no reason to encode the class at all;
 it's already known.
 (If the field is potentially nullable, the class is encoded as one byte,
 that specifies whether the value is 
\family typewriter
null
\family default
 or a value of the expected class.
 Only one bit is needed, but it's expanded to an entire byte to avoid the
 need for reads to cross byte boundaries.)
\end_layout

\begin_layout Subsection
Serializing noncopiable objects
\end_layout

\begin_layout Standard
For noncopiable objects, serializing them is mostly very simple.
 For a depth-1 serialization, we do a depth-0 serialization of each of its
 fields, and send those.
 For a depth-0 serialization, we just serialize it as a reference to the
 object.
 The interest in this sort of serialization, therefore, is in how those
 references are represented.
\end_layout

\begin_layout Standard
Mokapot's serialization actually takes place in two stages.
 In the first stage, which Mokapot internally calls 
\begin_inset Quotes eld
\end_inset

describing
\begin_inset Quotes erd
\end_inset

 the object, the output of the serialization consists of two separate parts:
 one representing the copiable data in the object being serialized (together
 with metadata like class names), the other representing the noncopiable
 data.
 The copiable data is represented as a sequence of bytes.
 The noncopiable data, however, is represented using references to Java
 objects – in other words, noncopiable objects seen within the serialized
 data are not serialized at all in a description, it simply contains a list
 of all the objects that need to be represented.
 Describing and undescribing an object, therefore, produces a shallow copy
 of it without any need to involve the garbage collection system (and historical
ly, this part of the serialization system was separate because Mokapot sometimes
 needed to make shallow copies of objects for reasons unrelated to sending
 them across a network; this capability is currently unused, but the separation
 of the serialization into stages still applies).
\end_layout

\begin_layout Standard
The second stage of serialization is internally known as 
\begin_inset Quotes eld
\end_inset

marshalling
\begin_inset Quotes erd
\end_inset

 the resulting description; unlike description, which works entirely with
 the local Java garbage collector, marshalling is heavily linked to the
 global Mokapot garbage collector (this relationship is explained in subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:GC-weight"

\end_inset

).
 To maintain garbage collection invariants, the marshalling of an object
 must be done in the knowledge of which JVM the object will subsequently
 be unmarshalled on, and the resulting stream of bytes must be unmarshalled
 exactly once, on the specified system.
 In this stage, the object is transformed into four values: its class (represent
ed as described above), the communication addresses (subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Communication"

\end_inset

) of the JVMs the object was marshalled on and should be unmarshalled on,
 and a globally unique ID number.
 (As an optimization, the values may be replaced with 
\family typewriter
null
\family default
s if it's known that they will be irrelevant.)
\end_layout

\begin_layout Standard
Noncopiable objects remain on their initial JVM during serialization (and
 during any other operation, other than migration); a JVM that receives
 a reference to a noncopiable object that isn't hosted there is therefore
 incapable of recreating the object itself (even if this were possible,
 it would be incorrect, because then there would be two independent copies
 of the object, one on the sending JVM and one on the receiving JVM).
 Instead, a proxy for the object is created during unmarshalling (subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proxies"

\end_inset

).
 If the receiving JVM needs to do anything with the object it has received,
 it will need to ask the sending system (which either hosts the object,
 or at least knows where it's hosted) to do so on its behalf; it can marshal
 the object just fine, despite not having a copy (it knows what systems
 the object is being marshalled on and unmarshalled on, and can just parrot
 the class and ID number information it was given), and thus can send requests
 about that object to the JVM where it's hosted.
 That system will then use the ID number to locate the object (the ID numbers
 of every object that's been marshalled are stored in a hash table, allowing
 location of the object).
 In summary, the marshalled form of a noncopiable object contains none of
 the object's data, but does contain sufficient information to perform operation
s on that object by forwarding them across the network.
\end_layout

\begin_layout Standard
There are some subtleties involved in marshalled noncopiable objects.
 One issue is that (except temporarily during migration) the JVM on which
 an object is hosted maintains a full accounting of which other JVMs have
 remote references to it (thus allowing recovery if a JVM crashes without
 properly declaring its references as having been freed).
 This means that when three or more JVMs are involved, it's impossible for
 a JVM (the sender) to directly send a second JVM (the recipient) a reference
 to an object hosted on a third JVM (the host) without getting the host
 involved (to inform it of the new location for the remote reference).
 Because a message has to be sent to the host anyway, the semantics of the
 message are chosen to make the algorithm as simple as possible (and thus
 more likely to be correct and easier to debug): the sender simply asks
 the host to marshal a reference to that object for unmarshalling on the
 recipient, thus making the code-paths involved the same as in the two-JVM
 case (in particular, this means that the same garbage collection algorithms
 can be used).
 The marshalled reference is relayed by the sender to the recipient (because
 it might well be a small part of a much larger serialized structure that
 was mostly created on the sender), but the sender doesn't (and for correctness,
 can't) unmarshal it itself; it just copies the sequence of bytes it sees
 and then forgets about them.
\end_layout

\begin_layout Standard
The other subtlety involved is related to migration.
 Normally, when a JVM receives a reference to an object, it will know where
 that object is hosted (this is a consequence of the special case in the
 previous paragraph: if the recipient isn't hosting the object itself, then
 the object must have been marshalled on the JVM that hosts it, so it can
 look at which JVM marshalled the reference, information included in the
 marshalled form of a reference, to determine which JVM to ask when performing
 operations on the object).
 However, if an object is migrated, its host changes, and the migration
 algorithm does not inform every JVM involved in the computation about the
 change immediately.
 As such, due to race conditions, a JVM may receive multiple references
 to the same object that imply different hosts for it.
 In order to know which host should be used, the 
\begin_inset Quotes eld
\end_inset

JVM the object was marshalled on
\begin_inset Quotes erd
\end_inset

 communication address is paired with a number listing the believed number
 of migrations that the object had undergone at that point; if the marshaller
 hosted the object at the time, this number will be accurate (the system
 that currently hosts an object always has up-to-date migration information
 for it), and if it didn't, the value will necessarily be ignored by the
 recipient, so its accuracy is irrelevant.
 This migration-count value can then be used to determine which information
 to ignore in the case of contradictory information about an object's location;
 whichever reference reports a higher count must have more up-to-date informatio
n, so the reference with the lower count is ignored.
 (This mechanism might seem irrelevant, given that the object might have
 migrated again anyway, but is important because it allows JVMs to be 
\emph on
informed
\emph default
 of a migration simply by sending them a reference to the object that was
 migrated; this means that information about migrated objects will tend
 to naturally spread very cheaply by piggybacking on other methods that
 were going to be sent anyway, thus tending to reduce the amount of residual
 garbage collector state involved in migration over time.
 Mokapot currently does not try to clean up this state intentionally, but
 a future version could do so without needing a separate codepath for it;
 simply sending any message mentioning the object's new location would be
 enough.)
\end_layout

\begin_layout Subsection
Serializing copiable objects
\end_layout

\begin_layout Standard
Serialization of copiable objects is mostly very simple; because making
 shallow copies of a copiable object does not change the program's semantics
 (by definition), it's typically possible just to send the class that the
 object belongs to, together with the values of its fields (recursively
 serialized), and to recreate the object based on those field values.
 The only difficult cases, therefore, come when the object cannot be represented
 as a list of field values; these cases are important both for correctness,
 and because they form the base case of the recursion.
\end_layout

\begin_layout Standard
The simplest base cases are primitives: 
\family typewriter
boolean
\family default
, 
\family typewriter
char
\family default
, 
\family typewriter
int
\family default
, and the like.
 These have obvious representations as a series of bits; Mokapot just outputs
 them directly into the serialization.
 There are a couple of subtleties even in this simple case.
 One is that Booleans are represented as an entire 8-bit byte, rather than
 as individual bits, in order to prevent the serialization becoming misaligned
 at the bit level, which would add considerable complexity to both encoding
 and decoding.
 Another is that there's no need to add additional metadata to cover the
 class of the field or a possible 
\family typewriter
null
\family default
 value; primitive-typed fields in Java can store only the primitive in question,
 and must always contain a valid value.
\end_layout

\begin_layout Standard
However, there are also more complicated values that can't be transmitted
 simply as a list of fields.
 Each of these needs its own special-case serialization defined.
 A good example is 
\family typewriter
String
\family default
 (whose internals are complex and not intended to be viewed by programs);
 Mokapot serializes this by outputting its length as four bytes, followed
 by the characters of the string encoded as UTF-8; the length is the number
 of UTF-8 bytes, allowing the deserializer to know where the string ends.
 It's also often possible to merge a representation of 
\family typewriter
null
\family default
 into the serialization format (e.g.
 
\family typewriter
String
\family default
 uses a length of 
\begin_inset Formula $-1$
\end_inset

); this means that just like with primitives, fields whose declared type
 is 
\family typewriter
final
\family default
 and special-cased need no metadata to reflect the type of the field (because
 as 
\family typewriter
final
\family default
 types cannot be inherited from, the only possible things a field of that
 type can contain are values of that type, and 
\family typewriter
null
\family default
).
 Another example of a class of this nature is 
\family typewriter
Class
\family default
 (because creation of a 
\family typewriter
Class
\family default
 object normally forces the class in question to be loaded on the recipient
 system).
\end_layout

\begin_layout Standard
Enumeration classes, classes extending 
\family typewriter
Enum
\family default
, are not 
\begin_inset Quotes eld
\end_inset

copiable
\begin_inset Quotes erd
\end_inset

 as Mokapot normally defines the word; a copy of an enumeration constant
 doesn't act the same way as the original, because enumeration constants
 are typically compared by address.
 However, the creation of new enumeration constants at runtime is typically
 forbidden, and thus all the JVMs involved in the computation, because they
 are running the same program, should have the same set of enumeration constants
 as a result.
 As such, the value in the field can be treated as a 
\emph on
reference
\emph default
 to an enumeration constant (e.g.
\begin_inset space \space{}
\end_inset

via specifying the class and the index within the array of all enumeration
 constants of that class), and those references can be copied from system
 to system, acting very much like copiable values; this means that enumeration
 values obey all the same requirements as copiable values and thus can be
 treated the same way.
\end_layout

\begin_layout Standard
Some classes can be forced to become copiable via small modifications.
 For example, 
\family typewriter
Inet4Address
\family default
, which represents network addresses accessible via Internet Protocol version
 4 (
\begin_inset Quotes eld
\end_inset

IPv4
\begin_inset Quotes erd
\end_inset

), is copiable within a single computer, but not onto a different computer
 (because an address may change meaning when moving onto a different network;
 both a hostname like 
\family typewriter
localhost
\family default
 and a numerical address like 
\family typewriter
192.168.1.1
\family default
 can have a meaning that's relative to the computer it's accessed from).
 However, there's an obvious translation of these addresses from one system
 to another (resolve it to a numerical address and send that; it's likely
 to have the same meaning on all computers involved in one computation),
 and a technique like this is required to 
\begin_inset Quotes eld
\end_inset

bootstrap
\begin_inset Quotes erd
\end_inset

 Mokapot (because Mokapot needs to be able to tell the various computers
 involved in the computation how to contact each other, and this can only
 be done with copiable objects because otherwise the machinery for handling
 method calls on noncopiable objects would depend on itself).
\end_layout

\begin_layout Standard
Of course, not every object graph traversal will end up terminating at primitive
s; it's possible to create a circular reference in Java.
 Although it would be possible to serialize these via cycle-breaking, Mokapot
 uses a different approach, of simply artificially declaring any potentially
 circular structure noncopiable (except in the special case of 
\family typewriter
Throwable
\family default
, which needs to be copiable because a JVM that has thrown an exception
 might not be contactable for details about it, and which is forced to become
 copiable via artificially breaking the cycle).
 The reason for this is that even in the case where the structure isn't
 circular, a class that can contain references to itself is often used to
 create some large recursive structure such as a linked list or binary tree,
 and even when these structures happen to be copiable, actually doing the
 copies on a regular basis could potentially be very slow.
 As such, even in the non-circular case, treating the structure as noncopiable
 is important for performance reasons, so there's no reason to write code
 to handle the circular case.
\end_layout

\begin_layout Section
Messages and concurrency
\end_layout

\begin_layout Subsection
Global threads and the global stack
\end_layout

\begin_layout Standard
Concurrency, in Java, is represented using the 
\family typewriter
Thread
\family default
 abstraction; the various threads of execution run simultaneously (and independe
ntly except when they communicate with each other via synchronization primitives
 or via one thread reading data for another to write).
 Mokapot aims to maintain the semantics of Java, meaning that it uses the
 same model for communication, with threads existing across the computation
 as a whole rather than existing on individual machines.
 (One minor difference is that a Java computation starts with a single main
 thread running the 
\family typewriter
main()
\family default
 method, and any further threads are created from there; under Mokapot,
 each JVM has its own 
\family typewriter
main()
\family default
 method and thus the program starts with more than one thread.
 Exact Java semantics can be regained via exiting all but one of these threads
 once the computation has started, and equivalently Java can emulate Mokapot's
 semantics via the use of a wrapper 
\family typewriter
main()
\family default
 that just starts a number of threads, so the distinction is not relevant
 in practice.) Mokapot's threads are known as 
\emph on
global threads
\emph default
 in order to distinguish them from Java's threads.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:thread-projections"

\end_inset

Maintaining the global stack
\end_layout

\begin_layout Standard
A thread has a call stack: a history of what method calls on that thread
 have started, but not yet ended.
 (Concurrency only exists between threads, not within threads, so each method
 on the call stack must have been called by the method before.) For static
 methods, a method call runs on the same JVM as its caller, meaning that
 the method will be in the same place as the previous method on the call
 stack, but for instance methods (methods with a 
\family typewriter
this
\family default
 argument), Mokapot runs the method on the JVM on which 
\family typewriter
this
\family default
 is stored; this means that a global thread's call stack can contain methods
 running on different JVMs.
 However, a Java call stack exists only on one JVM; thus, Mokapot needs
 to simulate call stacks itself.
\end_layout

\begin_layout Standard
The way in which this is done is to, for each global thread, maintain a
 
\emph on
thread projection
\emph default
 on every JVM on that thread's call stack.
 The JVM is a normal Java thread, which contains the calls made from that
 global thread on that JVM (the global thread's call stack is simply the
 combination of the thread projections' call stacks, and thus does not need
 to be stored separately).
 When a method calls another method on the same JVM, Mokapot need not do
 anything special; the program just makes a normal Java call, and the called
 method will be added to the thread projection's call stack (and thus the
 global thread's call stack) via the Java mechanisms.
 The same goes for the return from that method.
 As such, the interesting cases are those in which one method needs to run
 a method on another JVM.
 These typically happen as a consequence of a method being called on a proxy
 (Mokapot also provides an API via which a method can be explicitly run
 on a particular JVM, providing another means via which this can happen).
\end_layout

\begin_layout Standard
After this sort of cross-JVM method call is made, the thread projection
 on the calling JVM needs to continue existing – there are methods on its
 call stack – but it also needs to not be 
\emph on
running
\emph default
, because the global thread is running on a different JVM and concurrency
 does not exist within a single thread, only between threads.
 Thus, it needs to be suspended by some means.
 This is accomplished via calling a method, 
\family typewriter
receiveMessagesToThread
\family default
, that blocks on the receipt of a message, and then handles that message.
 (Information about the thread projection is also stored in a dictionary
 so that the networking code knows that it exists and can pass messages
 to it.) Each global thread is allocated a unique identifier, and messages
 that refer to events on a particular global thread will contain this identifier
 in their headers, so the networking code will pass any such messages to
 the appropriate thread projection to decode.
 (In addition to ensuring that everything runs on the correct thread, this
 mechanism also helps to prevent the networking code becoming blocked in
 message decoding.) The message could specify that the called method has
 returned, in which case 
\family typewriter
receiveMessagesToThread
\family default
 can return the same value/exception, or else it could be a method call
 (because the global thread called a method of an object on the original
 JVM and thus the call stack crosses from one JVM to another and back),
 in which case 
\family typewriter
receiveMessagesToThread
\family default
 calls the same method (and then replies to the message and goes back to
 waiting for a message once the method returns).
 In other words, 
\family typewriter
receiveMessagesToThread
\family default
 basically acts as a 
\begin_inset Quotes eld
\end_inset

placeholder
\begin_inset Quotes erd
\end_inset

 for the parts of a call stack that are running on a different JVM (which
 do not need to be visible to Java).
\end_layout

\begin_layout Standard
On the receiving side, the recipient JVM will have received a message mentioning
 the global thread in question.
 If the global thread's call stack already runs via that JVM, then a thread
 projection must already exist there (by definition), so 
\family typewriter
receiveMessagesToThread
\family default
 will already be running there and can receive the message, allowing it
 to continue the computation on the appropriate JVM.
 However, the thread projection might not exist if no method on the global
 thread's stack is running on that JVM; in that case, the networking code
 creates a new thread projection and uses that to decode and execute the
 message.
\end_layout

\begin_layout Subsubsection
Thread-local state
\end_layout

\begin_layout Standard
When a thread projection is created to process a message, it does so in
 almost the same way as 
\family typewriter
receiveMessagesToThread
\family default
: the message is decoded, an appropriate method is called as described in
 the message, and then the return value of the method call is sent as a
 reply to the message.
 The obvious thing to do at this point is to terminate the thread projection,
 to restore the normal invariants as to how thread projections work (because
 the global thread's stack trace no longer has any methods running on that
 JVM; it cannot have any due to the last-in-first-out nature of a stack,
 and the fact that there were none before the method was called).
 Unfortunately, there's a major subtlety: Java allows state to be associated
 with a particular (Java) thread.
 Simply terminating the thread projection (which is a Java thread) could
 cause that state to be lost, so Mokapot has to use a more complex algorithm.
\end_layout

\begin_layout Standard
In order to work out the correct semantics for this situation, we first
 need to look at how thread-local state is represented in Java.
 Java makes use of 
\family typewriter
ThreadLocal
\family default
 objects for this purpose; each such object is conceptually a map from threads
 to values, allowing each thread to store a different value within the 
\family typewriter
ThreadLocal
\family default
 object.
 Mokapot needs to reproduce this mechanism, allowing a 
\family typewriter
ThreadLocal
\family default
 object to store a different value for each 
\emph on
global
\emph default
 thread.
 For the most part, this needs no special handling; because access to these
 values requires calling a method on the 
\family typewriter
ThreadLocal
\family default
 object itself, any access to a particular 
\family typewriter
ThreadLocal
\family default
 object will always take place on the same JVM.
 As such, the keys used by the 
\family typewriter
ThreadLocal
\family default
 dictionary will effectively be the thread projections that correspond to
 the appropriate global thread, and this will have the same semantics as
 using the global thread itself as long as there's a 1-to-1 correspondence
 between (global thread, JVM) pairs and thread projections.
\end_layout

\begin_layout Standard
However, this correspondence will fail to hold if we ever allow a thread
 projection to exit and subsequently create a new thread projection for
 the same global thread on the same JVM.
 This means that the case in which a newly created thread projection is
 allowed to exit before the global thread does is semantically incorrect,
 and thus the thread projections need to be kept alive even when no methods
 are running on the particular global thread and JVM that the projection
 refers to.
 Mokapot uses 
\family typewriter
receiveMessagesToThread
\family default
 for this purpose, in addition to its more normal purpose of handling a
 
\begin_inset Quotes eld
\end_inset

missing
\begin_inset Quotes erd
\end_inset

 part of a call stack; in effect, it can be thought of as handling a 
\begin_inset Quotes eld
\end_inset

missing bottom of a call stack
\begin_inset Quotes erd
\end_inset

.
 This usage persists until the global thread as a whole exits (by returning
 from 
\family typewriter
run()
\family default
, the thread equivalent of 
\family typewriter
main()
\family default
); at that point, no further use can be made of the global thread, so all
 its thread-local state can be cleared.
\end_layout

\begin_layout Standard
In order to actually implement this clearing of local state, each message
 reply contains a flag that specifies whether a new thread projection was
 created as a result of the message.
 If this flag is set, the sender of the message will create a thread-local
 object to record the fact; this thread-local object will be kept alive
 by the same mechanism that it helps to implement, with each (possibly residual)
 thread projection recursively tracking the (possibly residual) thread projectio
n that was created immediately after it.
 However, once the thread itself exits altogether, nothing will be keeping
 the thread-local object alive on the JVM where the global thread originated,
 meaning that it gets deallocated; a garbage collector hook is used to observe
 the deallocation and send a message to the next residual thread projection
 that it's no longer needed, thus deallocating its tracking thread-local
 object, and so on until the entire global thread's (now defunct) local
 state has been cleared in a chain reaction.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Interruption"

\end_inset

Handling thread interruption
\end_layout

\begin_layout Standard
Java permits an asynchronous method of communication between threads by
 means of the 
\family typewriter
interrupt
\family default
 method; a thread can be interrupted regardless of what it is doing at the
 time, and this sets an 
\begin_inset Quotes eld
\end_inset

interruption flag
\begin_inset Quotes erd
\end_inset

 on the thread.
 A thread can check its own interruption flag; additionally, if a thread
 attempts to perform most blocking operations while its interruption flag
 is set (e.g.
\begin_inset space \space{}
\end_inset

sleeping, waiting for input, etc.), the operation will exit with an 
\family typewriter
InterruptedException
\family default
, clearing the flag.
 This mechanism avoids race conditions that could otherwise happen between
 an attempt to communicate with a thread, and that thread entering a blocking
 operation.
\end_layout

\begin_layout Standard
This mechanism is an issue for Mokapot's threading model because the interruptio
n flag is local to a specific Java thread, whereas it should conceptually
 apply to an entire global thread.
 Mokapot only needs to intervene in the case where the thread projection
 has an interruption flag but the global thread it belongs to is currently
 running in a different JVM; in this case, what happens is that 
\family typewriter
receiveMessagesToThread
\family default
 will either attempt to enter, or already be in, a blocking operation (blocking
 on the receipt of a message), so the 
\family typewriter
InterruptedException
\family default
 will be delivered to it.
 Conceptually, all it then needs to do is to send a message detailing the
 interruption over the network to the JVM where the global thread is actually
 running.
 (Note that unlike most messages pertaining to a thread, this message is
 
\emph on
not
\emph default
 addressed to the thread being interrupted, because it might be (probably
 will be) running at the time and thus unable to receive messages.
 Instead, a different thread will handle it and send an interruption to
 the thread in question using the normal Java interruption mechanism.)
\end_layout

\begin_layout Standard
There are, however, two issues with this mechanism.
 One issue is that there's no state tracking which JVM the global thread
 is running on; for each JVM to notify every other JVM that appeared on
 the global thread's call stack whenever the global thread moved from one
 JVM to another would be unacceptable overhead.
 Instead, the message describing the interruption is sent to the JVM immediately
 above the current JVM on the global thread's call stack (which is known
 because control flow moved to it from the current JVM, and it can remember
 having done so).
 If the global thread happens to be running there, the interruption has
 reached the correct place; otherwise, the interruption will reach a thread
 projection blocked in 
\family typewriter
receiveMessagesToThread
\family default
 and it will relay the interruption again.
 As the interruption always goes up the stack, which has finite size, it
 is almost guaranteed to reach the correct JVM eventually.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

almost
\begin_inset Quotes erd
\end_inset

 here is the second issue, caused by a race condition: it's possible that
 while the message detailing the interruption is being sent from one JVM
 to another, a message transferring control of the global thread (due to
 a method returning) is being sent in the other direction, with the messages
 crossing each other on the network.
 In this case, [...Mokapot's solution for this doesn't work either, it assumes
 that a thread projection won't be found, but that didn't work when it was
 written because the thread could have been in the process of exiting at
 the time, and doesn't work now for a different reason (the residual thread-loca
l state thread will see it and not know what to do)...]
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Communication"

\end_inset

Messages over the network
\end_layout

\begin_layout Standard
Mokapot expresses (almost) all communication between JVMs with the general
 concept of a 
\begin_inset Quotes eld
\end_inset

message
\begin_inset Quotes erd
\end_inset

, allowing it to be handled in a uniform way.
 This section talks about how the sending of a message is actually implemented.
\end_layout

\begin_layout Subsubsection
Establishing connections between JVMs
\end_layout

\begin_layout Standard
In order to be able to send messages at all, there is first a need to establish
 communication between the JVMs.
 Mokapot's model for starting a computation is that each of the JVMs involved
 initially runs independently (with Mokapot running on it listening for
 communications), and the first attempt by one JVM to send a message to
 another causes Mokapot to establish a communication channel between them.
 In order to do this, each JVM in the computation is given an 
\emph on
address
\emph default
; this is basically instructions on how to contact the JVM (normally the
 connection is done over a network, in which case would be an IP address
 and port number), together with information needed to authenticate the
 connection once made.
 Mokapot uses Transport Layer Security over TCP for authentication, with
 each JVM having a certificate (used as both a client certificate and server
 certificate, because connections are conceptually peer-to-peer rather than
 client/server).
 Authorization is done via signing each JVM's certificate with a certificate
 representing the computation itself; each JVM has access to this certificate's
 public key (but not its private key), and will allow connections only from
 JVMs whose own certificates are signed by the computation's; thus, certificates
 are being authorized directly (rather than principals), meaning that there's
 no need for the authentication system to be able to tie certificates to
 principals (having an authorized certificate is both necessary and sufficient,
 so the principals are not relevant at all).
 This also means that there is no need to involve external Certificate Authoriti
es (whose normal purpose in a public key infrastructure is to attest to
 the link between certificate and principal); and it provides a means to
 ensure that the certificates' serial numbers (which are set at the time
 the JVM's certificate is signed by the computation's certificate) contain
 no duplicates, allowing them to be used to uniquely identify particular
 JVMs in the computation.
\end_layout

\begin_layout Standard
Mokapot relies on the authorization system for the security of computations;
 as Mokapot's purpose is essentially to run arbitrary code based on network
 requests, any attempt to filter out disallowed requests based on their
 content would likely either be harsh enough to interfere with legitimate
 uses or else lenient enough to fail to stop an attacker, so reliable security
 relies on ignoring requests from anyone but authorized users (allowing
 a connection to be secured via ensuring only the owner of the machines
 involved has access to the private key corresponding to a JVM's certificate
 or that of the computation as a whole).
 Mokapot does support some mitigations against attacks even if the authenticatio
n layer fails: it runs code only from the class-paths of the machines involved,
 and is compatible with the use of Java's own security infrastructure to
 disallow access by the code it runs to categories of operations, such as
 file operations, that it is not expected to need (this access can also
 be disallowed to Mokapot, for operations that it in turn does not need).
 However, these mitigations are not expected to be sufficient on their own,
 and thus security relies mainly on protecting the certificates in question.
 Mokapot uses the standard format 
\begin_inset Quotes eld
\end_inset

PKCS #12
\begin_inset Quotes erd
\end_inset

 to implement this protection, with each JVM's PKCS#12 container storing
 the JVM's certificate and its private key, and the computation's certificate
 but not private key; the certificates in turn store the appropriate public
 key.
 The PKCS#12 containers themselves are password-protected files (
\begin_inset Quotes eld
\end_inset


\family typewriter
.p12
\family default
 files
\begin_inset Quotes erd
\end_inset

), thus both the file itself and its password are needed to be able to extract
 the private key (in a sort of two-factor authentication appropriate for
 computer use).
 The use of PKCS#12, despite being the normal mode of operation for Mokapot,
 is not required: Mokapot is also capable of making use of other forms of
 secure key storage (such as hardware security modules) via Java's own support
 for them, or even using other secure forms of communication (such as communicat
ion via shared memory when two Mokapot instances are running side-by-side
 in the same JVM, treating it as two JVMs).
\end_layout

\begin_layout Standard
In order to actually accept the communications, each JVM will open a server
 socket to listen for communications; when a communication arrives, the
 Transport Layer Security library will authenticate the sender and recipient
 to each other (who will then attempt to authorize the connection, and drop
 it if they fail to do so).
 The server socket will then continue listening for further communication.
 Normally the sender will ask the recipient to keep the newly established
 connection open and listen for messages on it (typically a precursor to
 immediately sending at least one message), but two other possibilities
 are available, indicated using the first byte sent over the connection.
 One is a request for the server to send its entire address object; this
 is used in cases where the sender knows the hostname and port of the recipient,
 but not other information contained in an address (such as its certificate's
 serial number), and is intended to make setting up Mokapot more user-friendly.
 The other is a special case used to allow clean shutdown of a Mokapot server
 socket; in order to shut down a server socket, Mokapot makes a connection
 from a JVM to itself, and uses a network connection to its own server socket
 to request a shutdown.
 This technique avoids any possible race conditions between accepting a
 connection and shutting the server socket down (because only one connection
 is ever in the process of being accepted at a time, and the self-connection
 causes it to be shut down during the acceptance process, so any attempt
 to newly connect to the JVM will either entirely succeed before the shutdown
 happens or else be rejected due to the socket being closed during acceptance
 of the previous connection).
\end_layout

\begin_layout Subsubsection
Low-level communication
\end_layout

\begin_layout Standard
With a connection established, the connection is used to send messages.
 Mokapot does not enforce a particular number of connections between two
 JVMs; if there are no connections currently established then the sending
 JVM will create a new connection via the recipient's server socket, if
 there are multiple connections currently established (perhaps due to a
 race condition in which two JVMs each simultaneously start a new connection
 with the other), an arbitrary connection will be used.
 This in turn means that connections can safely be shut down if they have
 not been used recently, avoiding socket leaks in cases where a long-running
 server is used with a large number of short-running clients.
\end_layout

\begin_layout Standard
In order to be able to reliably diagnose network issues, and avoid race
 conditions between message sending and socket shutdown, shutdown of these
 sockets is very regimented: a JVM that wants to shut a connection down
 will send a particular byte over that connection (but not immediately shut
 it down), the recipient (upon receiving that byte) will send the same byte
 back over connection socket and also shut it down at their end, then the
 first JVM will shut down the connection at its end upon receiving the response.
 Because JVMs will not send any further information on a connection after
 sending the shutdown byte (preferring to establish a new connection and
 use that), any messages that are 
\begin_inset Quotes eld
\end_inset

in flight
\begin_inset Quotes erd
\end_inset

 at the time of a shutdown will be fully received before the shutdown happens
 (because TCP preserves the order in which communications were sent); additional
ly, if both ends of a connection attempt to shut it down, each will interpret
 the other's shutdown byte as the response to its own shutdown byte and
 shut down immediately upon receiving it, meaning that that potential race
 condition does not cause issues either.
 All this means that an 
\begin_inset Quotes eld
\end_inset

end-of-file
\begin_inset Quotes erd
\end_inset

 condition, unexpected socket shutdown, etc.
\begin_inset space \space{}
\end_inset

should never happen, and is a clear indication of a connection failure if
 it does; any sort of connection failure causes a partially received message
 to be discarded, and a partially sent message to be resent on another connectio
n.
 This is not a fully reliable network failure recovery strategy, and we
 intend to implement a more general mechanism at some point, but so far
 it has proven to be effective at preventing network-related issues in practice.
\end_layout

\begin_layout Standard
Another issue is related to the efficiency of sending bytes over the network.
 There's a trade-off between latency and throughput.
 Sending a network packet requires both system calls to the kernel to place
 the packet onto the network, and the forwarding of the packet by the network
 itself, both fairly slow operations; thus, the best throughput is achieved
 by sending the bytes encoding more than one message in a single network
 packet.
 However, in order to send two or more messages together in the same packet,
 the sending of the earlier messages must be delayed until the later messages
 are available.
 This has an obvious latency cost simply due to the delay waiting for the
 later message to be ready, but also a non-obvious latency cost: there isn't
 a guarantee that another message will be available until the original message
 is sent (because it's quite possible that everything in the entire computation
 is blocked on the sending of the message in question), and thus an algorithm
 for grouping messages together needs to wait to see if another message
 will arrive, and in particular to decide when to stop waiting and simply
 send the message.
 As such, in the case where no additional messages become ready to send,
 the waiting is purely detrimental: it exists to optimize a case that didn't
 occur, at the cost of performance in the case that actually did occur.
\end_layout

\begin_layout Standard
The standard solution to this problem in TCP is to use Nagle's algorithm
 [cite: RFC 896], which merges packets adaptively based on the speed of
 the network: once a packet has been sent, any future output will be merged
 together into a single packet until the acknowledgment of the previous
 packet (thus, the faster/less congested/more reliable the network, the
 sooner new packets will be sent).
 However, network speed is the wrong parameter to scale on in this case:
 an ideal solution would predict whether another message would be due to
 be sent soon, because it is that parameter (rather than the speed at which
 previous messages were sent) that determines how much time is lost as a
 result of delayed messages.
 Mokapot's solution to the problem is therefore to scale on the amount of
 concurrency within the program, using the following simple technique: whenever
 Mokapot would send a message over the network, and isn't currently working
 on a network packet to send, it creates a new memory image for a network
 packet but doesn't send it immediately.
 Rather, the thread waits until every other thread on the JVM has been scheduled
 (possibly in parallel with another such thread or the waiting thread),
 and had a chance to run one time-slice (i.e.
\begin_inset space \space{}
\end_inset

until it attempts to perform a blocking operation like I/O or is pre-empted
 by the operating system); any messages that they attempt to send are appended
 to the same network-packet-in-progress.
 Finally, when all the threads have had a chance to contribute to the network
 packet, the cooperatively assembled network packet is sent.
\end_layout

\begin_layout Standard
The gain of Mokapot's algorithm for assembling messages into packets is
 that it doesn't waste any CPU time waiting; by definition, all the time
 spent between the message being prepared and actually sent is being used
 productively, because as soon as the CPU runs out of things to do, the
 message will be sent.
 (In the case of a single-threaded program with no pending background operations
 from things like garbage collector hooks, reads and writes will alternate,
 so delaying a write would be a pure waste of time; but in this case, all
 the other threads will be blocked, so the algorithm will send the message
 immediately with no waiting time.) It also captures the notion of 
\begin_inset Quotes eld
\end_inset

a message that's about to be sent
\begin_inset Quotes erd
\end_inset

, because each thread (that isn't blocked on I/O, a lock, or some similar
 issue) gets a chance to add any message it might be working on to the packet.
 (In the common case where all the classes required for serialization already
 exist in memory, message assembly is pure computation, no I/O involved,
 thus the thread's time-slice will probably end at the point where it finishes
 assembling the message and attempts to send it.) The actual delay will depend
 primarily on the number of threads that are running (especially threads
 that are in the middle of a long computation and whose time-slice ends
 via pre-emption rather than I/O); a large delay means that a large amount
 of concurrency is involved in the computation, which often helps to mitigate
 the effects of the large delay (there is probably a positive correlation
 between the amount of concurrency in different JVMs – programs tend to
 be mostly concurrent or mostly sequential – and if the other JVM is busy
 with many threads of its own, a delay in sending messages to it probably
 won't have an eventual effect on the speed of the computation).
\end_layout

\begin_layout Subsubsection
Addressing and decoding of messages
\end_layout

\begin_layout Standard
All this communication infrastructure exists to allow the messages themselves
 to be sent.
 When sending messages over the network, they of course need to be translated
 into a series of bytes; however, Mokapot's serialization code can be reused
 for this, with all messages being copiable objects that can thus be shallowly
 serialized and effectively sent directly.
 A major advantage of this technique, besides the fact that it leverages
 code that already exists in Mokapot, is that objects mentioned in messages
 do not themselves need to be serialized: a message can pertain to an arbitrary
 Java object, and its serialization routines will automatically recursively
 serialize it if it's copiable, or replace it with a reference if it's noncopiab
le.
 This makes messages much simpler than they might otherwise be (e.g.
\begin_inset space \space{}
\end_inset

a message asking to run a particular method with a particular list of arguments
 will just have fields containing a unique identifier for the method itself,
 and an array of objects to use as its arguments; there's no requirement
 on the arguments to be of any particular form, like would be required with
 most serialization methods).
 One potential issue with this is that serializing a message can cause another
 message to be sent, but no infinite regress is possible because messages
 that might potentially be sent recursively are of forms that can be serialized
 without further message-sending being required.
\end_layout

\begin_layout Standard
However, it isn't sufficient to just send the message itself; the recipient
 will need to know what to do with the message when it arrives.
 The sent object is thus a message 
\emph on
envelope
\emph default
: a structure consisting of a message itself, and an 
\emph on
address
\emph default
 that tells the recipient how to handle it.
 The address contains information on which thread needs to handle the message
 (allowing messages pertaining to a particular global thread, other than
 interruption messages (subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Interruption"

\end_inset

), to be handled on that thread); whether the message needs a reply (mostly
 used as a sanity check); which JVM sent the message (allowing replies to
 be routed correctly); whether the message should have an impact on migration
 (normally receiving a message about an object would discourage a JVM from
 migrating that object away, as the message has a chance of creating new
 persistent references to the object from that JVM, but this doesn't apply
 in cases where the reference to the object is known not to outlive the
 message); and information about what should happen if the message is received
 as Mokapot is shutting down (some messages, such as messages talking about
 the exit of a global thread, are known to be no-ops in this situation and
 thus can be safely ignored; other messages are more important).
\end_layout

\begin_layout Standard
Upon receiving a message, the recipient initially deserializes only the
 message's address (which is made out of primitives and Plain Old Data and
 thus is simple and fast to serialize and deserialize), avoiding issues
 in which the thread that receives network connections would slow down as
 a result of a complicated deserialization.
 The message address indicates whether the message can be deserialized quickly
 and run without blocking (by using a 
\family typewriter
null
\family default
 
\begin_inset Quotes eld
\end_inset

thread to handle this message
\begin_inset Quotes erd
\end_inset

 field); in this case, the message is handled before the next message is
 read from the network.
 In cases where it might take a long time to deserialize, or might block
 on something (this includes any messages that send a reply, because the
 sending of the reply might block on the network socket), the message is
 deserialized on a separate thread, normally the projection of the global
 thread it pertains to (but if no appropriate global thread is available,
 a fresh identifier will be used to identify 
\begin_inset Quotes eld
\end_inset

the global thread
\begin_inset Quotes erd
\end_inset

, causing a new 
\begin_inset Quotes eld
\end_inset

thread projection
\begin_inset Quotes erd
\end_inset

 for it to be created just to handle that one message, thus achieving the
 desired result with no actual extra code required).
 Replies to messages are implemented simply by sending a new message that
 serves as the reply (and does not itself need a reply).
\end_layout

\begin_layout Section
Object tracking and garbage collection
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proxies"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subsec:Location-managers"

\end_inset

Proxies and location managers
\end_layout

\begin_layout Standard
The purpose of Mokapot is to allow one computation to persist across multiple
 Java Virtual Machines.
 That means that an object that conceptually exists once within the computation
 as a whole may be referenced from multiple JVMs, each of which will need
 some sort of reference for the object.
 In the case of a copiable object, this is easy to implement – just store
 a separate copy of the object on each JVM – but noncopiable objects are
 more complicated.
\end_layout

\begin_layout Standard
Mokapot's solution to this is to store the object's data (i.e.
\begin_inset space \space{}
\end_inset

the fields that make up the object) on only one of the JVMs in the computation
 (so that there is a single, canonical place that determines what values
 the object has).
 That JVM therefore deals with the object itself (useful for performance
 reasons, as it means there is no overhead in a use of the object).
 The other JVMs are given a 
\emph on
proxy
\emph default
 for the object; this is an object with the same method signatures as the
 original object, but no actual data stored.
 Instead, whenever a method of the proxy is called, it serializes its arguments
 into a data structure, and sends it over the network to the JVM where the
 object is stored.
 The proxy's method then blocks, waiting for a reply.
 The recipient JVM will execute the method there, and sends the return value
 back over the network (again serializing it), enabling the proxy to then
 return the same value and thus effectively simulate the effect that the
 method call would have had on the original object.
\end_layout

\begin_layout Standard
In order for this mechanism to work, it is vital that Mokapot knows whether
 or not two objects should be treated as the same or not.
 (Two objects on the same JVM are always different from each other, but
 two objects on different JVMs may be conceptually the same object, if at
 least one is a proxy.) In order to accomplish this, Mokapot creates a separate
 object known as a 
\emph on
location manager
\emph default
 for each object that exists on more than one JVM (specifically, for each
 object that is not known not to exist on more than one JVM).
 Unlike objects, which are conceptually shared between JVMs, a location
 manager is specific to a single object/JVM pair, i.e.
\begin_inset space \space{}
\end_inset

each object has a separate location manager on each JVM where it exists.
\end_layout

\begin_layout Standard
The simplest purpose of a location manager is to check whether a referenced
 object already exists on a given JVM.
 Each object that needs a location manager is given a randomly generated
 ID number (with enough bits to make collisions vanishingly unlikely in
 practice); this number is permanently associated with the object (the way
 this works is that each proxy and object is given a back-reference to the
 corresponding location manager, and the ID number is stored in the location
 manager).
 There is also a hash table that stores all the location managers on a given
 JVM, indexed by ID number.
 When two JVMs are communicating with each other, and one needs to refer
 to a noncopiable object, it uses the ID number of the object; the remote
 JVM can then check to see whether it has a location manager with that ID
 number already, and thus whether it already knows about the object.
 If a location manager exists, then it can be used to locate the relevant
 object or proxy (as it holds a reference to it); if no location manager
 exists, then the object must be previously unknown, and a location manager
 and proxy for it can be created.
 This mechanism ensures that there are never duplicate copies of a noncopiable
 object, or duplicate proxies for it, on a given JVM.
 As explained in subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:not-methods"

\end_inset

, a mechanism like this is required to make the Java operator 
\family typewriter
==
\family default
 work correctly; it also reduces the overhead that would otherwise be introduced
 if many location managers or proxies were created for the same object.
\end_layout

\begin_layout Standard
Location managers are also used to store any other state that relates to
 a given JVM/object pair: in particular, metadata related to garbage collection
 and to migration.
 Locks associated with a given object are also stored in its location manager
 (because it is vital to avoid having multiple copies of a lock, as otherwise
 they would not be useful for avoiding race conditions); some operations
 only need to lock the object in one location (to avoid contradictory concurrent
 changes to its location manager), and if there is a need to lock the object
 
\begin_inset Quotes eld
\end_inset

globally
\begin_inset Quotes erd
\end_inset

 this is done by locking it in the place where the actual object is stored
 [...what's the deadlock prevention algorithm here? does Mokapot even have
 one or is there a potential deadlock in the code at the moment?...].
 Facts about objects that cannot change and might need to be referenced
 repeatedly are cached in each location manager describing the object, in
 order to avoid the need for network traffic to determine them.
\end_layout

\begin_layout Standard
Location managers are not conceptually garbage collection roots in their
 own right; they do not hold themselves alive, but rather are held alive
 by lifetime managers (subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:GC-weight"

\end_inset

) if the object is remotely referenced, and/or by the proxy or object itself
 if the object is locally referenced.
 As such, when a location manager is no longer needed, it is (at least in
 the idealized version of Mokapot) deallocated along with the object it
 describes.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Migration"

\end_inset

Migration
\end_layout

\begin_layout Standard
Migration is the process of moving the place at which an object's fields
 are stored from one JVM to another, without disturbing the semantics of
 the program.
\end_layout

\begin_layout Standard
The basic idea behind implementing migration is very simple: if we can make
 sure that we do not have any potential race conditions against methods
 that might access a field of the object directly (without calling a method
 on it), all we need to do is to make a depth-1 serialization of the object,
 send that serialization across the network to another JVM, and replace
 the local object in-place with a proxy to the new remote object.
 (It is possible to optimize this slightly, an optimization that Mokapot
 actually transforms: if the JVM that we're sending the object to has an
 existing proxy for the object, we replace that proxy in-place with the
 transmitted object, so that it doesn't need to proxy what is now a local
 object.)
\end_layout

\begin_layout Standard
As such, the main difficulty in migration comes from preventing race conditions
 against potential uses of the existing object.
 In Mokapot, a method can only access an object's fields directly if it
 is a method 
\begin_inset Quotes eld
\end_inset

of
\begin_inset Quotes erd
\end_inset

 that object, i.e.
\begin_inset space \space{}
\end_inset

that object is the message's 
\family typewriter
this
\family default
 parameter.
 So that means we need to prevent any such method calls on the object during
 migration, and need to ensure that any such method calls have ended before
 a migration occurs.
\end_layout

\begin_layout Standard
To implement this efficiently, objects conceptually have two states associated
 with them: a 
\begin_inset Quotes eld
\end_inset

potentially in migration
\begin_inset Quotes erd
\end_inset

 state, and a 
\begin_inset Quotes eld
\end_inset

not in migration
\begin_inset Quotes erd
\end_inset

 state.
 In the latter state, which is the default, direct calls to the object's
 methods are permitted using the normal Java mechanisms, with no attempt
 made to track them, meaning that we retain a high level of performance
 in the common case.
 To mark an object as being potentially in migration, it's replaced with
 a proxy that forwards all method calls to the original object, but takes
 a shared lock on the object's 
\emph on
migration lock
\emph default
 as it does so; this replacement is known as 
\emph on
preparing
\emph default
 the migration.
 This means that as long as a method call started after the migration was
 prepared, Mokapot will have a method of determining that the method call
 exists; the shared lock on the migration lock will prevent Mokapot taking
 an exclusive lock on the same lock.
 Thus, if the programmer explicitly asks for an object to be migrated (
\begin_inset Quotes eld
\end_inset

manual
\begin_inset Quotes erd
\end_inset

 migration), the correctness requirement is that no method calls on the
 object that started before the migration was prepared are still ongoing.
 Because this is an action taken in response to a user request, it is reasonable
 to ask the user to ensure that this correctness requirement holds.
\end_layout

\begin_layout Standard
The next potential problem is that locks only exist on a single JVM, whereas
 a migration inherently involves the use of multiple JVMs (and the JVM from
 which the user requests a migration might not be the same JVM where the
 object is stored, and indeed an object might be currently migrating at
 the time another migration is requested).
 To handle all potential race conditions along these lines, two main objects
 are used.
 A 
\family typewriter
MigrationActions
\family default
 object is the main user entry point for a migration: it contains a reference
 to an object (sort of; see below), and methods that can be called to perform
 various migration-related actions on the object (e.g.
\begin_inset space \space{}
\end_inset

preparing a migration, concluding a migration, actually migrating the object,
 and gaining information about the object's current location).
 A 
\family typewriter
MigrationMonitor
\family default
 is basically a sum type of two possible objects: one is a proxy for a 
\family typewriter
MigrationActions
\family default
 object on a remote JVM, and the other is a proxy for a correctly locked
 migration lock for the object in question (on any JVM, either local or
 remote).
 Whenever an attempt is made to call a migration action on an object, the
 
\family typewriter
MigrationActions
\family default
 object creates a 
\family typewriter
MigrationMonitor
\family default
 for the object: the object's local migration lock is taken exclusively
 (blocking if necessary), then a check is made to see if the object is local
 (doing it in this order means that if the object is local, it won't move
 after we check this because we're holding the migration lock).
 If the object is local, we just hold the lock; if it isn't, we release
 the lock and proxy to a 
\family typewriter
MigrationActions
\family default
 object that we newly construct (via message) at the object's 
\begin_inset Quotes eld
\end_inset

last known location
\begin_inset Quotes erd
\end_inset

.
 (The last known location is either the object's actual location, or else
 a location the object migrated away from more recently than the last time
 the object was here.
 Repeatedly following last known locations between JVMs will thus eventually
 reach the actual location of the object.) If we end up with a proxy set
 of migration actions, the local migration action simply delegates to them;
 if it ends up with an exclusive migration lock, it knows that the object
 cannot be migrated by anyone else while the lock is held (and if the migration
 has been prepared, no methods can be called on the object while the lock
 is held either).
 Thus, this technique allows a JVM to ensure that there can be no interference
 with any of the migration actions.
\end_layout

\begin_layout Standard
In addition to preparing a migration, and 
\emph on
committing
\emph default
 (i.e.
\begin_inset space \space{}
\end_inset

actually carrying out) the migration, there's a 
\emph on
conclude
\emph default
 operation that's the inverse of a prepare: it replaces the proxy for an
 object with the object itself, thus ceasing to track method calls on the
 object and regaining an amount of performance.
 (This can be done even while there are active method calls via the proxy;
 our model for object replacement is that existing method calls will continue
 with the old object, and only new method calls with the new object.)
\end_layout

\begin_layout Standard
The prepare/commit/conclude protocol explained above is how manual migration
 requests are handled.
 Mokapot also contains a partial implementation of a second migration process,
 
\emph on
automatic migration
\emph default
, which is used for both performance and correctness reasons.
 The basic idea is that if an object has no remaining incoming references
 from the JVM on which it is stored, it is likely to be more efficient to
 store the object elsewhere (especially if it has not been referenced locally
 for some time, thus precluding the possibility that the object is repeatedly
 passed as a parameter of some method that runs on the JVM where the object
 is stored); and doing so is a necessary part of the garbage collection
 algorithm, as it resolves cross-JVM reference cycles on objects that are
 inaccessible except for the cycle.
 Additionally, if the object has no remaining incoming references, it is
 impossible for any currently ongoing method calls to access fields of the
 object without going via Mokapot (a local reference would be needed to
 do so locally, and going via Mokapot necessary to do so remotely).
 Thus, in this case, there is no actual need to prepare the migration; Mokapot
 uses the migration lock for all remote calls of an object's methods regardless
 of whether the migration was prepared or not, so as long as the lack of
 local references can be guaranteed, merely taking an exclusive lock on
 the migration lock is enough to guarantee that migration is safe.
 (The lack of an explicit prepare also means that the conclude can be made
 implicit, via generating the object in non-proxy form after the migration.)
\end_layout

\begin_layout Standard
Unfortunately, automatic migration was disabled in Mokapot, before it was
 fully implemented, due to an inability to get the necessary guarantees
 from the garbage collector (section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:JVM-GC"

\end_inset

).
 This means that the full details of how to choose the destination for an
 automatic migration were never decided: an obvious choice would be to migrate
 to the location of the first method call made remotely on the object, but
 (in order for the garbage collection algorithm to be correct) some decision
 would also need to be made in the case where an object cycle is completely
 inaccessible, and thus no method calls will occur on it.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:GC-weight"

\end_inset

Lifetime managers and GC weight
\end_layout

\begin_layout Standard
Because Mokapot is running on multiple JVMs, their garbage collectors are
 going to be active, collecting any objects that aren't locally referenced.
 However, that collection will have false positives: an object that has
 no local references within the JVM might still have references from other
 JVMs.
 Thus, Mokapot includes a distributed garbage collector that works in cooperatio
n with the JVMs', correcting the cases that they get wrong.
\end_layout

\begin_layout Standard
The first step in writing the distributed garbage collector is to prevent
 the JVM freeing any objects that are still in use from remote systems.
 This is accomplished using 
\emph on
lifetime managers
\emph default
, objects that record the fact that a local object is referenced from a
 remote JVM.
 If an object on JVM 
\begin_inset Formula $A$
\end_inset

 is referenced by a reference on JVM 
\begin_inset Formula $B$
\end_inset

, then there will be a location manager on 
\begin_inset Formula $B$
\end_inset

 tracking the reference, and a lifetime manager on 
\begin_inset Formula $A$
\end_inset

 tracking the same thing; there will also be a location manager on 
\begin_inset Formula $A$
\end_inset

 that tracks the object itself (rather than the reference).
 The lifetime manager on 
\begin_inset Formula $A$
\end_inset

 holds a reference to the location manager on 
\begin_inset Formula $A$
\end_inset

 (which in turn keeps the object alive), so the object cannot die on 
\begin_inset Formula $A$
\end_inset

 as long as the lifetime manager is alive; and lifetime managers are treated
 as roots for the JVM's garbage collection algorithm (by storing them in
 a map which is in turn referenced from a static variable).
 So as long as the lifetime managers are kept up to date, objects cannot
 possibly be freed early.
 Additionally, as long as we ensure that lifetime managers exist only when
 the remote reference exists, objects cannot be freed late, unless they're
 part of an otherwise unreferenced reference cycle spanning multiple JVMs
 (as mentioned in subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Migration"

\end_inset

, this case is resolved by migrating all the objects onto the same JVM,
 where the garbage collection will be handled entirely by the JVM's garbage
 collector, which is capable of detecting and breaking the reference cycle).
\end_layout

\begin_layout Subsubsection
Preventing early deallocation using GC weight
\end_layout

\begin_layout Standard
There are two main complexities in maintaining the set of lifetime managers.
 One is to keep the set of lifetime managers up to date with a minimum of
 network traffic between the JVMs.
 The other is to ensure that an object isn't freed if it's currently referenced,
 not by any individual JVM, but rather by a network message that's currently
 in transit between multiple JVMs.
 Both of these complexities are handled by a system called 
\emph on
GC weight
\emph default
 (the GC stands for 
\begin_inset Quotes eld
\end_inset

garbage collection
\begin_inset Quotes erd
\end_inset

).
 GC weight is intuitively a resource that 
\begin_inset Quotes eld
\end_inset

belongs
\begin_inset Quotes erd
\end_inset

 to an object, and can be transferred between JVMs (the actual 
\begin_inset Quotes eld
\end_inset

transferring
\begin_inset Quotes erd
\end_inset

 is done via remembering where the GC weight is on each of the JVMs involved,
 i.e.
\begin_inset space \space{}
\end_inset

GC weight is an entirely virtual resource with no physical representation).
 Whenever a JVM 
\begin_inset Formula $A$
\end_inset

 sends a message about an object stored there to a JVM 
\begin_inset Formula $B$
\end_inset

, an arbitrary amount of GC weight (the exact amount doesn't matter as long
 as it's positive) will be included as part of the message; the amount of
 GC weight pertaining to an object 
\begin_inset Formula $x$
\end_inset

 that was sent from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

 will be remembered by a 
\emph on
lifetime manager
\emph default
 on 
\begin_inset Formula $A$
\end_inset

 that records references from 
\begin_inset Formula $B$
\end_inset

 to 
\begin_inset Formula $x$
\end_inset

.
 If 
\begin_inset Formula $B$
\end_inset

 wants to keep a remote reference to 
\begin_inset Formula $x$
\end_inset

, all it has to do is to hold onto the GC weight (on 
\begin_inset Formula $B$
\end_inset

, the amount of GC weight 
\begin_inset Quotes eld
\end_inset

borrowed
\begin_inset Quotes erd
\end_inset

 from 
\begin_inset Formula $A$
\end_inset

 is remembered by 
\begin_inset Formula $x$
\end_inset

's location manager); it can do this, with no ill effects, even if it already
 had a reference to 
\begin_inset Formula $x$
\end_inset

 (meaning that in this common case, no additional network traffic is needed
 to ensure that the garbage collection algorithm works correctly).
 When 
\begin_inset Formula $B$
\end_inset

 no longer needs the reference to 
\begin_inset Formula $x$
\end_inset

, it returns all the borrowed GC weight by means of a separate message sent
 directly to 
\begin_inset Formula $A$
\end_inset

; this will be removed from the record in the lifetime manager (and when
 the lifetime manager is managing a GC weight of 0, it deallocates itself,
 thus ceasing to hold the location manager alive).
 If 
\begin_inset Formula $B$
\end_inset

 wants to send a message about 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset

, it will include a small portion of the borrowed GC weight along with the
 message.
 (If it wants to send a message about 
\begin_inset Formula $x$
\end_inset

 to a third system 
\begin_inset Formula $C$
\end_inset

, it will ask 
\begin_inset Formula $A$
\end_inset

 to prepare the reference to 
\begin_inset Formula $x$
\end_inset

 in question; that allows 
\begin_inset Formula $A$
\end_inset

 to make a lifetime manager that records references from 
\begin_inset Formula $C$
\end_inset

 to 
\begin_inset Formula $x$
\end_inset

, and the GC weight will be relayed via 
\begin_inset Formula $B$
\end_inset

 to 
\begin_inset Formula $C$
\end_inset

.)
\end_layout

\begin_layout Standard
The GC weight system therefore ensures that an object cannot be deallocated
 if messages referring to it are in transit, or references to it exist on
 another JVM: the lifetime managers hold the object alive until all the
 borrowed GC weight is returned, and are the only source of GC weight for
 the object; and any message and any JVM referencing the object will have
 a positive amount of GC weight for the object stored within it.
 Thus, for all the weight to be returned to its source, there must be no
 stores of it left, thus no references to the object from messages and from
 other JVMs.
 This system is comparable to, but not identical to, reference counting:
 with reference counting, you count the number of references that exist,
 each with equal weight; but with the GC weight system, references to the
 object have arbitrary (but tracked) positive weights, and the total weight
 is what is remembered.
 This extra flexibility means that there's no need to track the exact number
 of references that exist, meaning less network traffic is needed to handle
 this case.
\end_layout

\begin_layout Standard
One obvious simplification of this system would be to use a single number
 to track all the lent GC weight, rather than splitting it up between lifetime
 managers that are each dedicated to a specific remote system.
 However, this simplification has a major downside: although it is possible
 to make such a system robust against failures, doing so involves a large
 amount of network traffic, as with no knowledge of where references to
 a particular object might exist, any 
\begin_inset Quotes eld
\end_inset

keep-alive
\begin_inset Quotes erd
\end_inset

 messages used to indicate that an object was still alive would have to
 mention the object specifically (and there would be a need to mention which
 objects were still alive, not which objects were lost, because the record
 of which objects were referenced from a JVM would be stored on that JVM
 and thus lost if the JVM failed).
 Requiring a message to mention every object to which a remote reference
 exists does not scale well; the number of such references could potentially
 be quite large.
\end_layout

\begin_layout Standard
Mokapot's policy of splitting up the records of lent GC weight among different
 lifetime managers, while superficially more complex, allows for an almost
 trivially simple algorithm for cleaning up objects whose only remaining
 references were from failed JVMs: every 15 seconds: each JVM sends a keep-alive
 message to each JVM it has borrowed GC weight from, specifying that it's
 still alive.
 If GC weight has been lent to a JVM, and no such message has arrived for
 30 seconds, the JVM is known to have failed, and all the GC weight lent
 to it can be removed from the garbage collection records.
 The advantage of this system is that it scales, in the worst case, on the
 square of the number of JVMs involved (rather than the number of (referencing
 JVM, referenced object) pairs involved), and that processing the keep-alive
 messages is very fast in the common case (only a single timer is needed
 for each pair of JVMs, which clears all the relevant lifetime managers
 when it expires, and the keep-alive message simply resets the timer; the
 only slow operation is the actual clearing of all the lifetime managers,
 and that only happens in an exceptional situation).
\end_layout

\begin_layout Subsubsection
Garbage-collecting objects that have been migrated
\end_layout

\begin_layout Standard
When an object migrates, this produces some extra complexities in garbage-collec
ting it, which are also handled by the GC weight system.
 The normal invariant – that all GC weight is borrowed from the JVM where
 the object is stored – is replaced by a slightly more complex invariant,
 that all GC weight is borrowed directly from a JVM where the object 
\emph on
has been
\emph default
 stored, but may be borrowed 
\emph on
indirectly
\emph default
 from the JVM where the object is currently located.
\end_layout

\begin_layout Standard
In more detail, the way this works is that when an object 
\begin_inset Formula $x$
\end_inset

 migrates from a JVM 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 will be given enough GC weight (by 
\begin_inset Formula $B$
\end_inset

) to cover all the GC weight that had previously been borrowed from 
\begin_inset Formula $A$
\end_inset

 (plus an arbitrary positive amount extra).
 This ensures that 
\begin_inset Formula $A$
\end_inset

 will always contain a net positive amount of GC weight, and thus that 
\begin_inset Formula $B$
\end_inset

 will not deallocate the object until all references to it have been deallocated
 from other JVMs (whether 
\begin_inset Formula $A$
\end_inset

 or a third party).
 As the object is deallocated on JVMs that borrowed GC weight from 
\begin_inset Formula $A$
\end_inset

, they will return the GC weight to 
\begin_inset Formula $A$
\end_inset

 (which, to decrease network traffic, hangs onto it until 
\begin_inset Formula $A$
\end_inset

's lifetime manager is referenced neither locally nor from lifetime managers,
 at which point it can return all the borrowed GC weight to 
\begin_inset Formula $B$
\end_inset

 in a lump sum).
 Eventually, no GC weight borrowed from 
\begin_inset Formula $A$
\end_inset

 will remain, leaving the garbage collection invariants in the same state
 as if the object had been on 
\begin_inset Formula $B$
\end_inset

 all along.
\end_layout

\begin_layout Standard
In order to simplify the GC weight tracking, and reduce the extent to which
 migration can have lasting effects, each location manager can borrow weight
 from only one other JVM at a time: if it receives GC weight from multiple
 JVMs, it immediately returns all but one source of the weight.
 A 
\begin_inset Quotes eld
\end_inset

borrow of GC weight
\begin_inset Quotes erd
\end_inset

 is accompanied by a record of which JVM it was borrowed from, but also
 how many times the object had migrated at the time that the borrow occurred;
 because GC weight is always borrowed from the current location of the object,
 this makes it possible to determine which of the two borrows is older,
 and the older borrow can be returned at that point, relying only on the
 newer borrow.
 This means that only one borrow ever needs to be recorded in the location
 manager, and also means that borrows of GC weight from old locations of
 the object will tend to disappear over time.
\end_layout

\begin_layout Standard
It should be noted that this tracking system is safe against race conditions
 even if an object is migrated repeatedly, or back to an old location: any
 of the locations where the object has been will act as a source of GC weight
 until they're no longer needed to do so, and will always be aware of how
 much they've lent to other systems: the core invariant that the net GC
 weight stored in a message or JVM will be positive unless the JVM is the
 current location of the object is maintained.
 One problem is that if a JVM crashes while an object is being migrated,
 before the GC weight borrows have been consolidated in one place, it may
 be impossible to track what needs to happen to the object.
 However, in the case of migration, this is not a major issue because if
 the JVM had crashed slightly earlier, the object would have been hosted
 there and thus lost altogether (meaning that recovering from this failure
 mode is fairly unimportant because a worse failure mode also exists).
\end_layout

\begin_layout Part
\begin_inset CommandInset label
LatexCommand label
name "part:Mokapot-JVM"

\end_inset

Making Mokapot work with the JVM
\end_layout

\begin_layout Standard
[do we want to discuss startup/shutdown?]
\end_layout

\begin_layout Standard
So far, this report has been discussing a view of Mokapot as though it could
 perform arbitrary operations on objects; for example, it would ideally
 want to be able to replace an object with a standin for that object, that
 allowed transparent proxying of any operations on that object.
 However, Mokapot is not an abstract concept, but a concrete program designed
 to run on a specific runtime: in this case, the Java Virtual Machine, commonly
 known as the JVM.
 There are several operations that Mokapot would want to be able to perform,
 but the JVM does not support; for example, in Java, the code which is run
 when a particular method is called on an object is fixed at the time that
 the object is created, and thereafter cannot be changed.
 As a result, Mokapot needs to use workarounds to handle cases which would
 exist in an idealized language, but not on the JVM.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:standins"

\end_inset

Standin classes
\end_layout

\begin_layout Standard
The idealized version of Mokapot wants to be able to override the functionality
 of an object in arbitrary ways, from subtle (changing the behaviour of
 methods so that they take a lock while running) to extreme (outright replacing
 the object with one that forwards any action on the object to another system
 via the location manager).
 However, Java is rather inflexible in this regard; any reaction an object
 might have to a method being called on that object is fixed at the time
 the object is created (because it depends on the object's 
\begin_inset Quotes eld
\end_inset

vtable
\begin_inset Quotes erd
\end_inset

, which in turn depends purely on which class the object belongs to).
 As such, Mokapot makes heavy use of 
\emph on
standin classes
\emph default
; these are classes that can be switched into a number of different modes,
 each of which mimics a different object that might have existed in the
 idealized version of Mokapot.
 For example, one possible mode for a standin simply acts identically to
 an object of a particular class in the user's code; however, unlike the
 original class, it can be switched into a different mode and then gains
 different behaviour (e.g.
\begin_inset space ~
\end_inset

forwarding method calls elsewhere, ignoring its own state).
 As such, we can implement the 
\begin_inset Quotes eld
\end_inset

replace object
\begin_inset Quotes erd
\end_inset

 functionality we'd want – which is not supported by the JVM from within
 a running program – with a 
\begin_inset Quotes eld
\end_inset

change the mode of this standin
\begin_inset Quotes erd
\end_inset

 method, and simply use standin objects (i.e.
\begin_inset space ~
\end_inset

objects of standin classes) for everything rather than the objects specified
 in the original program.
\end_layout

\begin_layout Standard
Of course, such a heavy use of standin objects might cause performance problems,
 as they are necessarily more complex than the original objects.
 An obvious improvement is to use them for noncopiable objects only (as
 copiable objects never need replacing, as they can just be copied).
 Mokapot actually uses a more extreme optimization than this: standin objects
 aren't used unless the user specifies that they might be necessary, or
 an operation requiring a standin object has actually occurred.
 Of course, this means that a few operations (such as manual migration)
 are not possible on objects for which this was not envisaged at the time
 the object was created, but Mokapot's basic functionality all works even
 without the need to replace existing objects.
\end_layout

\begin_layout Subsection
Standin class functionality
\end_layout

\begin_layout Standard
Standins allow us to mimic an idealized object-oriented language in Java
 via implementing functionality indirectly via the standin object, allowing
 us to control how that functionality works.
 A single standin object might be used for a variety of purposes over the
 lifetime of the program, so it can be placed into different modes depending
 on what its current purpose is.
\end_layout

\begin_layout Standard
The simplest of these modes is a 
\emph on
trivial
\emph default
 standin.
 In this case, the standin is a thin wrapper around a Java object; calling
 a method on the standin just calls it on the object, and returns the same
 result.
 The behaviour of method calls on the standin should thus be equivalent
 to method calls on the Java object, meaning that if a program is edited
 to create a trivial standin in a situation in which it was previously creating
 a Java object, there should be no observable difference to the program.
 The existence of trivial standins thus make it possible to make a program
 standin-based without any change in its functionality.
\end_layout

\begin_layout Standard
Despite their triviality, trivial standins are nonetheless useful.
 One benefit is that the trivial standin implements a number of additional
 methods, above those implemented by the object itself; in particular, this
 includes serialization methods.
 This helps to avoid the need to use reflection (which is slow) when serializing
 an object; instead of needing to access the fields of the object one-by-one
 by name, the generated code within the standin is specialized to a particular
 class, so can simply access any public fields directly (or any fields with
 getter methods via those getter methods).
 The current version of Mokapot does not make much use of this optimization
 opportunity, but the framework for it is in place, thus allowing the optimizati
on to be implemented as part of future work.
 Besides serialization-related methods, standins also implement a method
 to invoke another method via number, which basically just generates code
 that searches for the method in a jump table and calls it; just as with
 serialization, the aim is to avoid slowdown due to the use of reflection
 (and to implement a sort of constant-folding: method numbers can be hardcoded
 in generated code, to avoid a need to look up a method by name every time
 an indirect method call is made).
 Standins also implement a range of methods related to manipulating metadata
 of the standin itself, e.g.
\begin_inset space \space{}
\end_inset

they have a method to switch them into a different mode.
\end_layout

\begin_layout Standard
One issue with adding all these additional methods is the potential for
 name collisions with methods in user code; it would cause problems for
 a user's method to shadow a standin method or vice versa.
 This is solved via the use of method overloading: in Java, the parameter
 types that a method takes are effectively part of its name, and two methods
 with different parameter types are considered to be different methods.
 Therefore, Mokapot adds an additional parameter to each of the standin-specific
 methods, that has a Mokapot-specific type and thus won't appear in the
 user's code; the existence of the additional parameter prevents naming
 clashes.
 The additional parameter has a second purpose: its type requires it to
 be of a class that has no public constructor, and thus cannot be created
 by the user code.
 Verifying that this parameter is not 
\family typewriter
null
\family default
, therefore, is a useful sanity check to ensure that the Mokapot-specific
 methods cannot be called from outside Mokapot (Java's regular privacy system
 cannot be used to ensure this, because standin classes belong to the same
 package as the class they're standing in for, not Mokapot's package).
\end_layout

\begin_layout Standard
A second mode of standins has a very similar behaviour to the trivial standin,
 with method calls acting just as with a trivial standin.
 The difference is that this version of a standin effectively adds an additional
 field to the object; the purpose of this field is to store a reference
 to the object's location manager.
 As explained in section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:JVM-GC"

\end_inset

, Java's garbage collection hooks are not fully general, but additional
 garbage collection functionality can be implemented via allowing for 
\begin_inset Quotes eld
\end_inset

backwards
\begin_inset Quotes erd
\end_inset

 links in the object graph, and the extra field allows the creation of such
 a backwards link.
 (Only one backwards reference is needed; any further such references that
 might be necessary can be referenced from the location manager.)
\end_layout

\begin_layout Standard
The remaining mode of standins has rather different functionality: it does
 not forward methods directly to a Java object at all.
 Rather, it encapsulates the method call into a data structure: each possible
 method that could be called on the object is given an arbitrary number,
 and the method call is thus captured as the method's number, plus its parameter
 list.
 The resulting data structure is sent to the location manager, to allow
 it to implement the method call.
 (If the object is on the local JVM at the time, the standin will still
 be associated with it, so the location manager will invoke the method indirectl
y on the standin: the encapsulate-and-forward functionality only affects
 direct calls onto the standin, with calls indirectly via the standin going
 to the underlying object.) If the object is not on the local JVM at the
 time, the data structure will be sent over the network to the object's
 current location, and used to call the method indirectly via the standin
 on that JVM.
\end_layout

\begin_layout Standard
This forwarding behaviour of standins is used for two purposes.
 The more obvious purpose is to implement a cross-JVM reference; a standin
 is used as a proxy for an object on one JVM, and method calls on it will
 thus be forwarded to the object on the remote JVM.
 The less obvious purpose is that even for a local object, the indirect
 nature of method forwarding means that the method call is observable to
 the location manager, and it is therefore able to track the currently ongoing
 method calls on an object.
 Objects cannot be safely migrated while they are being used as the 
\family typewriter
this
\family default
 of a method call, so this technique allows a migration to be delayed until
 it is safe.
\end_layout

\begin_layout Standard
When a standin is being used in forwarding mode, it can be useful for the
 standin to contain an object's data, so that indirect calls can be made
 on it; however, if no indirect calls are being made, the Java object associated
 with the standin is effectively irrelevant.
 Depending on what technique was used to implement the standin, the Java
 object might be the standin itself, but it might be a separate object.
 In the latter case, it is useful to be able to 
\begin_inset Quotes eld
\end_inset

drop the standin's referent
\begin_inset Quotes erd
\end_inset

, i.e.
\begin_inset space \space{}
\end_inset

deallocate the useless Java object that belongs to the standin, in order
 to prevent a memory leak.
 (Of course, before the standin can be switched out of forwarding mode,
 or used to make indirect method calls, a new Java object needs to be created
 as the standin's referent, and its fields set appropriately.) Dropping and
 undropping referents therefore serve as two final pieces of standin functionali
ty; in general, Mokapot drops the referent of a standin whenever the object
 it's standin in for is on another JVM.
 (Another advantage of this is that there is no need to create a referent
 when a standin is being created as a proxy, as opposed to becoming a proxy
 some time after its initial creation.)
\end_layout

\begin_layout Subsection
Standin techniques
\end_layout

\begin_layout Standard
Unfortunately, Java does not support any 100% general ways of creating a
 proxy for an object; the basic problem is that the functionality of an
 object's methods are defined by its class, and fields and variables are
 limited to holding objects of particular classes, so changing a method's
 functionality (as a proxy must) can mean that the resulting proxy cannot
 be used to stand in for the original object.
 As such, a range of techniques are used to attempt to find replacements
 for objects that act as similarly to the original object as possible.
\end_layout

\begin_layout Standard
Java's standard library contains a proxying library for creating objects
 of given types (which is used, for example, by Java RMI), and works by
 forwarding the method name and parameters for any method call on the proxy
 to a separate object.
 However, this is limited to interface types.
 This limitation is often unacceptable (e.g.
\begin_inset space \space{}
\end_inset

it's very common to give a concrete type rather than interface type when
 specifying the type of a field).
 However, it is not problematic in cases where the object's actual type
 is one that is unlikely to be used as the type of a field, e.g.
\begin_inset space \space{}
\end_inset

an anonymous class within the Java API, with 
\family typewriter
Object
\family default
 as its superclass (such classes are only intended to be used via interfaces
 they implement).
 Mokapot originally implemented support for generating this kind of interface-on
ly object using Java standard library proxies, but abandoned this when a
 strictly more functional alternative was discovered.
 The idea is to find the closest superclass of the object that can be extended
 (ideally the object's class itself), and use that as the superclass of
 the proxy (while implementing all the same interfaces that the object does).
 That way, the object can be stored not only in variables with an interface
 type, but also variables with a concrete type that happens to be no more
 specific than the chosen superclass; in the case where the object's own
 class can be extended, the proxy can be stored everywhere the original
 object can be.
 (Non-copiable classes which cannot be extended – 
\family typewriter
final
\family default
 classes, and non-public classes within the Java API – are generally problematic
 for standin generation, and at present typically cause Mokapot to use a
 type of standin that is not fully general.
 This problem may be impossible to fix without altering the program's source
 code.)
\end_layout

\begin_layout Standard
Of course, despite being general in terms of functionality, this sort of
 proxying is somewhat wasteful in terms of memory usage; all the fields
 of the extended superclass need to be present in the proxy (because in
 Java, subclassing an object cannot delete fields from it, even if all the
 superclass's methods are overridden to not use them), but are unused.
 The object's actual data is stored elsewhere (in a 
\begin_inset Quotes eld
\end_inset

referent
\begin_inset Quotes erd
\end_inset

 object of the same type as the object being proxied), because having an
 object belonging to the correct class is necessary to actually be able
 to call methods on it and get the right results, leading to a second copy
 of the fields.
 Mokapot thus therefore supports a couple of optimizations to try to avoid
 this issue.
 One of them is to detect circumstances where the standin is being used
 only from within Mokapot, and therefore to not bother about allowing methods
 to be called on it directly nor to allowing it to be stored in the same
 fields and variables that as the original object; Mokapot won't have method
 names and types from the user's code hard-coded, meaning that method calls
 will be made indirectly and variables used to hold user objects will use
 dynamic rather than static type checking.
 In this case, there is no need to get the superclass right, so Mokapot
 can use a superclass of its own that is optimized for this purpose.
\end_layout

\begin_layout Standard
The other potential optimization, when the object's type can be extended,
 is to use the standin itself as its own referent (an 
\begin_inset Quotes eld
\end_inset

inheritance-based
\begin_inset Quotes erd
\end_inset

 standin).
 In this case, the standin's methods will override those of the object,
 but the object's methods still need to be usable; when the standin is in
 trivial mode, they need to forward to the original methods (without 
\emph on
being
\emph default
 the original methods, as the standin's methods need to stay the same even
 when the standin switches mode, and thus need to act conditionally depending
 on the mode); and when the standin is in forwarding mode, the standin needs
 to be able to implement indirect method calls by calling the original object's
 methods (calling the standin's methods would forward the method calls rather
 than performing them).
 The Java Virtual Machine has an opcode 
\family typewriter
invokespecial
\family default
 that allows a superclass's version of a method to be called on an object,
 rather than the version from the object's actual class; when the standin
 is its own referent, this is the only way to actually run the object's
 methods.
 Unfortunately, there is no way to 
\family typewriter
invokespecial
\family default
 
\begin_inset Quotes eld
\end_inset

dynamically
\begin_inset Quotes erd
\end_inset

 or via reflection, meaning that this sort of proxy can only be implemented
 via code that has the method name hard-coded.
 As such, this sort of standin can only practically be implemented via code
 generation, looking to see what method calls an object supports, and then
 generating byte-code containing an 
\family typewriter
invokespecial
\family default
 for each such method and loading that byte-code as a class (this is of
 course trivial to do using ahead-of-time compilation, but Java also supports
 doing this in a just-in-time manner).
\end_layout

\begin_layout Standard
There are some advantages, besides optimization, to using a standin as its
 own referent.
 Mokapot is normally only capable of handling method calls on proxies, and
 fails with all the operations that do not involve method calls (such as
 direct access to a field, which if it even types correctly, will see an
 unused field from the standin's superclass).
 However, when an object is local, such operations will end up referring
 to the standin when called from other objects, and the referent when called
 from the object itself (which is normally what is wanted, as the referent
 is where the object's data is stored, and an object's data should normally
 only be referred to from the object itself).
 In some cases, however, we would want to refer to the standin even when
 the method is being called from the referent (for example, if the object
 decides to store a reference to itself in a collection, the reference would
 need to be to the standin in case the object subsequently migrates); having
 the standin and referent be the same object implements these cases automaticall
y.
\end_layout

\begin_layout Standard
There is sometimes also a big reason not to do this; creating all objects
 as standins would be very inefficient (and require the use of a source
 code or byte-code transformation to replace every use of 
\family typewriter
new
\family default
 in the program with a standin creator).
 This means that sometimes, an object already exists when Mokapot realizes
 that a standin for it is needed.
 When the standin and referent are separate objects (a 
\begin_inset Quotes eld
\end_inset

composition-based
\begin_inset Quotes erd
\end_inset

 standin), this is very easy to implement; just use the object as the standin's
 referent rather than creating a new one.
 The object will be impossible to migrate until it becomes clear that all
 existing references directly to the referent have died, but this is a fairly
 minor drawback.
\end_layout

\begin_layout Standard
Because there are trade-offs between the various standin implementations,
 Mokapot uses an optimization algorithm to select an ideal standin type
 for each situation.
 A range of standin 
\emph on
functionalities
\emph default
 are defined, including things like the ability to migrate the wrapped object,
 the ability to call various sorts of methods on the object (e.g.
\begin_inset space \space{}
\end_inset

methods of the object's class, or methods of the object's interfaces), and
 the ability to generate the standin when the object's class is hard to
 proxy in some way (such as belonging to the Java API).
 Whenever a piece of code within Mokapot needs a standin for an object,
 it specifies what functionalities it needs, and what functionalities it
 potentially might need; the standin technique system uses a lexicographical
 preference system to find a standin implementation which supports the required
 functionalities, and as many of the most preferred potential functionalities
 as possible.
 If multiple implementations are equally good (which can happen if, e.g.,
\begin_inset space \space{}
\end_inset

hardly any functionalities are needed), the tie is broken based on how time-
 and memory-efficient the implementations are.
\end_layout

\begin_layout Standard
This mechanism allows for extra robustness in the face of, e.g.,
\begin_inset space \space{}
\end_inset

missing or broken dependencies (simply add extra standin implementation
 techniques, even if they have nothing to recommend them they'll still be
 chosen if all else fails).
 It also some extra optimization opportunities in cases where very minimal
 functionality is required: sometimes there's no need to use anything heavy
 as a standin because something much lighter will have the same function.
 For example, it's sometimes possible simply to use a Java object of the
 correct type, rather than an actual standin, because no standin functionality
 is actually required.
 At the opposite extreme, if a standin exists only within Mokapot to serve
 as a placeholder for some object that will be sent to a remote system,
 and won't be used locally, there's no point in having any standin functionality
 on the local system other than the ability to record the object's ID number,
 and thus a standin implementation will be used that does that and only
 that.
\end_layout

\begin_layout Standard
Despite all Mokapot's standin generation fallbacks, sometimes a class is
 simply impossible to create any sort of standin for.
 Mokapot takes note of these situations when doing copiability inference,
 and has one last approach for trying to make the code work: sometimes it's
 possible to arbitrarily treat copiable classes as noncopiable in order
 to change the set of classes that will need standins.
 This technique is nowhere near fully general, but can help avoid the need
 to generate a standin for a problematic class (in favour of generating
 standins for less problematic classes) and thus increases the set of programs
 on which Mokapot can run.
\end_layout

\begin_layout Subsection
Standin code generation
\end_layout

\begin_layout Standard
In order for Mokapot to use standin classes, it actually needs to create
 these classes.
 There are two main ways in which Mokapot can accomplish this.
\end_layout

\begin_layout Standard
The simpler method is to make use of APIs intended for the creation of proxies.
 These work by generating a class that overrides every method of the class
 or interface being proxied to call a callback method, rather than performing
 its normal functionality; specifying a particular callback method then
 makes it possible to give the class arbitrary behaviour.
 In the case of a proxy for a class which only exists to implement an interface,
 so that the proxy could have 
\family typewriter
Object
\family default
 as its superclass, this can be accomplished easily using the Java standard
 library, which provides an API 
\family typewriter
java.lang.reflect.Proxy
\family default
 for the purpose.
 However, as explained in the previous section, Mokapot does not currently
 make use of this API, because it would be helpful only in a special case,
 and thus is subsumed by implementations that would work in more general
 cases.
 (There is another special case of a standin, that where a proxy creation
 API would otherwise be needed, but objects of the standin class are never
 stored in a field or variable that has constraints on what can be stored
 there; Mokapot does have a special case for this, using a single hard-coded
 standin class for all such standins and thus avoiding the need to create
 the standin class at all.)
\end_layout

\begin_layout Standard
Instead, when Mokapot needs to use a proxy creation API, it uses a third-party
 library, 
\begin_inset Quotes eld
\end_inset

Javassist
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.javassist.org/
\end_layout

\end_inset


\end_layout

\end_inset

, which provides a proxy creation API that allows specifying arbitrary interface
s and an arbitrary superclass (overriding all the methods of both to call
 a callback method).
 This has effectively the same purpose as 
\family typewriter
java.lang.reflect.Proxy
\family default
, but is more general.
 This mechanism can be used to create standins for any class.
 However, it has two major drawbacks.
 One is the resulting standins are fairly slow (because all method calls
 are overridden via a single callback method, the callback method needs
 to make use of slow reflection APIs to be able to call the correct method
 on the referent).
 The other is that it is hard to make it work correctly for inheritance-based
 standins: with such standins, there is a need to be able to call methods
 of the superclass on arbitrary objects of the class without going via the
 methods of the class itself (that override them), and this sort of cross-class
 
\family typewriter
invokespecial
\family default
 operation cannot be expressed in Java directly nor via Java reflection.
 (It 
\emph on
is
\emph default
 possible to express, because Javassist provides an API to do this as long
 as the overridden method is running at the time, but would be excessively
 complex because the overridden method would not typically be naturally
 running at the time.
 As such, Mokapot would need to synthesize a dummy call to it, and also
 add some external means of indicating to the method that it shouldn't perform
 its normal behaviour; the method parameters would not be suitable for this,
 as Mokapot has no control over what types they have or whether they exist.
 As such a mechanism would only be a fallback in any case, as proxy creation
 APIs are normally unnecessary, this level of complexity does not seem to
 be justifiable and has not been implemented.)
\end_layout

\begin_layout Standard
A faster solution is for Mokapot to generate the byte-code of the standin
 class directly.
 To accomplish this, Mokapot uses another third-party library, 
\begin_inset Quotes eld
\end_inset

ASM
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://asm.ow2.io/
\end_layout

\end_inset


\end_layout

\end_inset

, that provides a higher-level interface to the generation of Java byte-code
 than outputting it a byte at a time.
 Mokapot can therefore make use of ASM to generate a standin class almost
 from scratch.
\end_layout

\begin_layout Standard
These generated standins start by declaring the superclass and interfaces
 of the resulting standin, just like when using Javassist; they also add
 in any additional interfaces that allow parallel methods to be called (subsecti
on
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:non-overridable"

\end_inset

), and a field to track which mode the standin is in (this also indirectly
 holds the backwards link when the standin is in backwards-link mode or
 the location manager when the standin is in forwarding mode).
 Most of the interest in the generated standins comes from the methods,
 though.
 The most vital functionality is to override all the existing methods of
 the superclass and the interfaces; but this step is a little different
 from when Javassist is used, because each method now has separate code
 and thus can have method names hard-coded into it.
 This means that there is no need to use slow reflection APIs, or complex
 workarounds to do an 
\family typewriter
invokespecial
\family default
 operation; the generated methods simply check which mode the standin is
 in, and call the appropriate method on the standin's referent, or store
 the method parameters into a data structure and forward it, accordingly.
\end_layout

\begin_layout Standard
Next most important is a generated method 
\family typewriter
invoke
\family default
 that is placed onto all the standins Mokapot generates from scratch.
 This takes the data structure created by the overridden methods as an argument,
 and calls the appropriate method on the standin's referent with the given
 parameters.
 For a composition-based standin, this is simply an optimization that saves
 time over the use of reflection (because the method call can be hard-coded
 using a jump table).
 However, it is what makes inheritance-based standins work; the appropriate
 method in this case is the method from the standin's superclass (or possibly
 a default method from an implemented interface), and thus it can be called
 directly using a hard-coded 
\family typewriter
invokespecial
\family default
 instruction (important because the reflection API does not support a mechanism
 to do this).
 Although it is unusual for one method to invoke a method that's overridden
 by a different method of the same class, this is legal within Java, thus
 JVMs will support the resulting byte-code.
\end_layout

\begin_layout Standard
The rest of the generated standin class is less important for correctness,
 but still useful from the point of view of optimizations.
 The general idea is to replace anything that would normally be accomplished
 using reflection, or stored using fields of the standin that do not vary
 between two standins for objects of the same class, with a generated method
 that has all the relevant class, method, field, etc.
\begin_inset space \space{}
\end_inset

names hard-coded, to save time over the use of the reflection API.
 (These methods are effectively 
\begin_inset Quotes eld
\end_inset

static
\begin_inset Quotes erd
\end_inset

 methods, in the sense that they are not implemented on the object directly
 but rather take an arbitrary object of the right type to be a standin referent
 as their argument.
 This allows Mokapot to, e.g.,
\begin_inset space \space{}
\end_inset

serialize objects it hasn't previously encountered without needing to create
 a standin specifically for the purpose.
 However, the methods are implemented as instance methods that ignore 
\family typewriter
this
\family default
, so that they can be called without the need for reflection and without
 the need to hard-code the name of the standin class into Mokapot itself,
 something which would obviously be impossible for a user's own classes.)
 This is not fully implemented in Mokapot at present; many of the simpler
 methods are specialized in this way, but the more complex methods generally
 just defer to the general-purpose reflective implementations that are used
 for the Javassist-generated standins.
\end_layout

\begin_layout Standard
One of the more complex methods that 
\emph on
is
\emph default
 sometimes optimized by Mokapot is the method that determines how large
 (in bytes) the serialized form of an object could be.
 When Mokapot needs to know this size, the general-purpose method for determinin
g it iterates over the object's fields, checking the serialized size of
 each in turn, and adding them together.
 However, it is common for classes to inherently have a cap on how large
 a serialization of their objects can become (e.g.
\begin_inset space \space{}
\end_inset

because each of their fields is an 
\family typewriter
int
\family default
 or similar type that has only finitely many possible values).
 Mokapot can recognize this situation as it is generating the standins,
 and will then generate a 
\begin_inset Quotes eld
\end_inset

size-counting
\begin_inset Quotes erd
\end_inset

 method that simply returns a hard-coded number, much faster than iterating
 over the fields.
\end_layout

\begin_layout Standard
The ASM-based standin generation method is not currently usable in all cases.
 Although it theoretically could be used for everything, and ideally will
 be in future (because it is both more efficient and more general than the
 Javassist mechanism), it is much more complex than the use of a proxy creation
 API would be, and thus is not currently implemented for all standin types
 (it also is not currently implemented in cases where the byte-code of the
 standin's referent class is not available, although the original class's
 byte-code is not actually a requirement for generating a standin for it).
 In cases where it is used, Mokapot supports using it in two different ways.
 One possibility is to generate the standins ahead of time, enabling them
 to be shipped with the user's program (or in the case of standins for Mokapot's
 internal classes, with Mokapot itself).
 This possibility saves time that would be needed to generate the standins
 at runtime (although it may nonetheless be slower, because disks are so
 much slower than CPUs are that the cost of regenerating the standin on
 every use of the program may be lower than the cost of reading the standin's
 byte-code from disk).
 The other possibility is to simply generate and load the standin class
 the first time it would be needed.
 Mokapot's current algorithm for this is to check whether the standin class
 exists on disk already; if not, attempt to generate it using ASM; if that
 is impossible or unimplemented, to generate the standin class using Javassist;
 and if that is also impossible, to give up and produce an error.
 This therefore leads to a variety of different implementations of standins
 (because there are multiple standin techniques, and multiple ways to generate
 standins even if they have the same technique), but it almost always ends
 up finding some appropriate implementation.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:JVM-GC"

\end_inset

Interfacing with the JVM's garbage collector
\end_layout

\begin_layout Standard
Many parts of Mokapot involve tracking objects, and as such, care is needed
 to cooperate with the JVM's garbage collector; often, Mokapot will need
 to keep objects alive because they are referenced locally (even if unreferenced
 remotely), and even more often, Mokapot needs to be able to refer to an
 object without affecting its garbage collection properties (e.g.
\begin_inset space \space{}
\end_inset

Mokapot needs to store a unique ID for every object that has ever been sent
 over the network, and to be able to refer to the object by ID, but it also
 needs to allow the object to be deallocated when it's no longer referenced
 from everywhere, and to avoid leaking the ID – i.e.
\begin_inset space \space{}
\end_inset

leaving the memory for the ID allocated despite no longer being useful –
 when this happens).
\end_layout

\begin_layout Subsection
Responding to object deallocation
\end_layout

\begin_layout Standard
One of the most important interactions with the JVM's garbage collector
 is to gain a notification when an object becomes unreferenced.
 This is a common problem in Java more generally, and as such Java has a
 number of APIs for doing this.
 One of the safest, albeit least general, is the 
\family typewriter
PhantomReference
\family default
 mechanism (which Mokapot uses by preference in all cases in which it works);
 a 
\family typewriter
PhantomReference
\family default
 is basically an object that, if it still exists at the time, adds itself
 to a 
\begin_inset Quotes eld
\end_inset

reference queue
\begin_inset Quotes erd
\end_inset

 when a particular object becomes unreferenced, without actually referencing
 that object.
 A background thread can then look at the reference queue to see which 
\family typewriter
PhantomReference
\family default
s exist on it, and run code accordingly (e.g.
\begin_inset space \space{}
\end_inset

to tell a remote JVM that an object became locally unreferenced).
\end_layout

\begin_layout Standard
One issue with this is that the 
\family typewriter
PhantomReference
\family default
 does need to be held alive; this mechanism adds additional flexibility
 to the Java API (in that it allows a computation as a whole to just be
 discarded at once when it's no longer needed), but it's flexibilty that
 Mokapot doesn't need (Mokapot and its communicator must be running for
 it to make sense for the objects in question to need their deallocation
 monitored, and we always want to react to it; even if the communicator
 is shut down we want to process the deallocation of the objects it contains
 before the shutdown process finishes).
 As such, there's a need to be able to unconditionally protect the references
 in question from deallocation.
 Mokapot does this using a global variable that (being global) acts as a
 garbage collection root, holding a multiset of objects that are being kept
 alive (implemented as a map from objects to integers).
\end_layout

\begin_layout Standard
Another issue is that Java's garbage collector is asynchronous: it won't
 report that an object has become unreferenced immediately, but rather some
 time later, when it actually does become unreferenced.
 In most cases, this is not a problem (e.g.
\begin_inset space \space{}
\end_inset

it makes no difference to the computation if we report an object's deallocation
 late; we end up in the same state either way).
 However, while the communicator is being shut down, locating all the unreferenc
ed objects becomes somewhat urgent: further execution on the program is
 blocking on being able to prove that no objects remain referenced from
 multiple JVMs.
 As such, there's a need to ask the garbage collector to act more quickly.
 Threads in Java can call 
\family typewriter
System.gc()
\family default
 in order to request that the JVM puts extra effort into garbage collection;
 but we want to avoid a situation in which a large number of threads making
 duplicate garbage collection requests at once, slowing down the program
 (especially because a JVM may wish to ask a different JVM to garbage collect,
 and when a large computation is shut down everywhere at once, there will
 be a large number of such requests).
 This situation is handled routing all requests increase garbage collection
 via the same thread that reads the reference queue, which will merge duplicate
 requests (as long as at least one call to 
\family typewriter
System.gc()
\family default
 is made 
\emph on
after
\emph default
 any incoming request to do so, something which typically prevents merging
 two requests into one, but permits merging three or more requests that
 happen in quick succession into two).
\end_layout

\begin_layout Subsection
Storing extra information without memory leaks
\end_layout

\begin_layout Standard
For some interactions with Java's garbage collector, a 
\family typewriter
PhantomReference
\family default
 is insufficient.
 For example, in the case of recording an object's unique ID, we need to
 be able to locate an object by ID without preventing the object being deallocat
ed; the reference to the object must exist (so that we can locate the object),
 and thus cannot be phantom.
 In this case, it is possible to use a different Java API, the 
\family typewriter
WeakReference
\family default
, to reference the object; this is similar to a 
\family typewriter
PhantomReference
\family default
 but allows the reference to be followed as long as the object is still
 allocated, without preventing its deallocation (if the object does get
 deallocated, the reference 
\begin_inset Quotes eld
\end_inset

breaks
\begin_inset Quotes erd
\end_inset

 and will return 
\family typewriter
null
\family default
 if accessed).
 Mokapot commonly uses these to form maps with weakly-referenced keys, which
 are in turn used to associate additional information with objects even
 in the common case where those objects have no unused fields to store the
 information in.
\end_layout

\begin_layout Standard
Unfortunately, there is a major problem with this sort of map (despite existing
 as part of Java's standard library).
 With simple values in the maps, like unique IDs, there is no issue; but
 if a value could potentially contain a reference (even indirectly) to its
 own key (or a number of values each contain a reference to another's key
 in a cycle), this causes a memory leak; the garbage collector sees a strong
 reference from the map to the value and from the value to the key, and
 thus assumes that all the values are needed.
 There are at least two theoretical solutions to this problem.
 One solution is to use a data structure known as an 
\emph on
ephemeron
\emph default
 [citation?], which is a data structure consisting of a key/value pair that
 keeps the value alive for as long as the key is reachable via a route that
 does not involve the value.
 This solution is sadly unusable, because ephemerons cannot be implemented
 in Java.
\end_layout

\begin_layout Standard
An alternative solution, which is equivalent to an ephemeron (in the sense
 that each can be implemented in terms of the other), is the 
\begin_inset Quotes eld
\end_inset

reverse reference
\begin_inset Quotes erd
\end_inset

; a normal reference from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

 prevents 
\begin_inset Formula $B$
\end_inset

 from being garbage-collected for as long as 
\begin_inset Formula $A$
\end_inset

 is reachable, whereas a reverse reference from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

 prevents 
\begin_inset Formula $A$
\end_inset

 from being garbage-collected for as long as 
\begin_inset Formula $B$
\end_inset

 is reachable, with both normal and reverse references making it possible
 to access 
\begin_inset Formula $B$
\end_inset

 given a reference to 
\begin_inset Formula $A$
\end_inset

.
 (An ephemeron with key 
\begin_inset Formula $K$
\end_inset

 and value 
\begin_inset Formula $V$
\end_inset

 can be implemented using a weak reference to a pair object 
\begin_inset Formula $P$
\end_inset

, which in turn contains a reverse reference to 
\begin_inset Formula $K$
\end_inset

 and regular reference to 
\begin_inset Formula $V$
\end_inset

.
 If 
\begin_inset Formula $K$
\end_inset

 is reachable without going via 
\begin_inset Formula $V$
\end_inset

, the reverse reference will hold everything else alive; otherwise, there
 is no strong reference to 
\begin_inset Formula $P$
\end_inset

, so it and then 
\begin_inset Formula $V$
\end_inset

 will be deallocated.) Reverse references cannot be in general implementable
 in Java (because they can be used to implement ephemerons), but a simple
 implementation is available when the target of the reference has an unused
 field available; a reverse reference from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

 is simply a combination of a weak reference from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

 and a regular (strong) reference from 
\begin_inset Formula $B$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset

 stored in an unused field of 
\begin_inset Formula $B$
\end_inset

.
 This makes it possible to store arbitrary amounts of additional information
 about an object using only a single additional field (for objects that
 are part of Mokapot, this field is provided when required).
 [note: I'm not entirely sure this idea is even used in Mokapot any more,
 but it's an interesting piece of research to come out of this, so if it's
 new it's probably worth posting in this paper or another...]
\end_layout

\begin_layout Standard
It is also sometimes possible to work around this problem via the use of
 a different algorithm.
 For example, Mokapot needs to avoid creating two different standins for
 the same object on the same JVM, meaning that each JVM needs to track which
 standin belongs to each pre-existing Java object.
 The obvious solution is a weak-keyed map associating objects with standins,
 but unfortunately the standin naturally needs a reference to the object,
 so this solution won't work: an ephemeron or reverse reference would be
 needed, and cannot be implemented because the keys are the user's Java
 objects (which probably won't have a spare field).
 Instead, Mokapot makes the map in question both weak-keyed and weak-valued;
 if the standin ends up being deallocated while the value is still alive,
 this will probably hurt efficiency (because if the standin is needed again
 there will be a need to recreate it), but it still performs the job of
 preventing two standins being created simultaneously for the same object
 (if the standin gets deallocated early then it no longer exists), and two
 standins for the same object that do not exist simultaneously are almost
 indistinguishable (the only ways to tell would be via using the 
\family typewriter
==
\family default
 operator which requires a reference to each argument, or via 
\family typewriter
System.identityHashCode
\family default
 which Mokapot does not support).
\end_layout

\begin_layout Subsection
Expirable objects
\end_layout

\begin_layout Standard
One problem faced by Mokapot is that in many cases, an object is supposed
 to only exist while a condition is true, and be deallocated afterwards.
 A good example is lifetime managers, which should only exist while holding
 a nonzero amount of garbage collection weight.
 (There are other examples, such as objects that refer to live connections
 between two JVMs, and should be deallocated if the connection breaks.)
\end_layout

\begin_layout Standard
Java normally uses a system in which objects are not explicitly deallocated,
 but rather freed when they become unreferenced.
 However, in cases where an object exists for a specific purpose and is
 useless afterwards, avoiding race conditions often requires an atomic deallocat
ion-like property; it is important that existing references to the object
 are no longer used after the object's task is complete, because they would
 modify an object that might be deallocated at any time (losing the information
 in it).
 Mokapot therefore has its own deallocation-like concept: an 
\emph on
expired
\emph default
 object is one that must not be used and is treated as nonexistent for every
 purpose, although references to it can still exist.
 Expirable objects are always kept alive until they have expired; any part
 of Mokapot that can have a reference to an expired object will drop that
 reference once it notices the expiry, so the object will also eventually
 become deallocated.
 For weak references to expired objects, the 
\family typewriter
null
\family default
ed-out state indicating that the reference target has been deallocated,
 and a reference to an expired object, are treated the same way.
\end_layout

\begin_layout Standard
In order to ensure that methods cannot be called on expired objects, every
 method of these objects checks for its expiry before doing anything, and
 while holding a lock of some sort that prevents the expiry state changing
 (the lock is released only when the method's job is complete).
 If the method is called on an expired object, a checked exception is raised,
 forcing the caller to take some alternative action that accounts for the
 object it wanted to use no longer existing (for example, it could recreate
 the object in question, or remove it from a map).
\end_layout

\begin_layout Standard
Uses of expirable objects include lifetime managers (expired when holding
 0 GC weight, to avoid a race condition between the deallocate/recreate
 and borrowing GC weight from them); connections (so that data isn't sent
 over an expired connection, and to prevent it being closed twice); tracking
 to see when a thread has ended, so that other systems can drop residual
 state relating to it (to avoid a race condition between the thread ending
 and the communicator shutting down); and in the implementation of maps
 whose keys and values are both weak (to handle a three-way race between
 the map entry being deallocated because the key is deallocated, the map
 entry being deallocated because the value is deallocated, and a new map
 entry being added).
 In general, it serves as a flexible scheme to avoid race conditions in
 situations where at least one of the racing events is an object becoming
 deallocated or unreferenced.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:loose-reference"

\end_inset

Responding to local deallocation
\end_layout

\begin_layout Standard
Phantom references and weak references make it possible to observe when
 an object has no strong references remaining.
 They both, however, come at the cost of losing access to the object itself.
 For the purpose of automatic migration, Mokapot wants to be able to observe
 when an object has no local references remaining, but still keep it alive
 so that remote references can call methods on the object.
 That means that we need a reference to the object that we can actually
 follow, but it isn't strong (we need to be able to react to no remaining
 strong references existing), isn't phantom (it needs to be an actual reference)
, and isn't weak (we need to be able to follow the reference even after
 all the strong references break).
 Java has only one remaining type of reference, the 
\begin_inset Quotes eld
\end_inset

soft
\begin_inset Quotes erd
\end_inset

 reference, but those are not useful in this situation either (soft references
 act like strong references most of the time, and like weak references when
 memory pressure is high, and unpredictably switching between two inappropriate
 types of reference cannot lead to an appropriate type of reference).
\end_layout

\begin_layout Standard
Instead, what we need is a type of reference which can identify when an
 object is unreachable via 
\emph on
other
\emph default
 types of reference, but continues to reference the object and continues
 to prevent its deallocation.
 Mokapot calls these 
\emph on
loose references
\emph default
.
 Ideally, loose references would be weaker than strong references, but stronger
 than soft references; if an object ceased to be strongly reachable, but
 was still loosely reachable, the group of all loose references via which
 the object became reachable would all start acting as strong references,
 with some observable side effect indicating the group as a whole.
 (Mokapot uses the term 
\emph on
tight reference
\emph default
 to describe a loose reference that has become strong.
 The metaphor is of references that have some slack in them, holding the
 object only loosely into the object graph and unnecessary as long as it
 is being held rigidly in place by stronger references, but tautening when
 they become necessary to prevent the object detaching and thus under strain.)
\end_layout

\begin_layout Standard
This specification of loose references would enable reliable implementation
 of automatic migration; the lifetime managers for an object would all reference
 a shared loose reference which in turn referenced the object itself.
 If a loose reference became tight, this would be a guarantee that no other
 local references to the object existed.
 If a subsequent local reference to the object were added, it would need
 to go via a tight reference (possibly indirectly); being aware of the entire
 group of tight references via which the object could be reachable, all
 such references would be set back to loose in the process, thus maintaining
 the invariant that objects with a tight reference to them have no (non-tight)
 strong local references.
 (It is possible, with some object graphs, that only some of the group can
 indirectly access the particular object that became newly locally referenced,
 and other references were included in the group for the benefit of some
 other object that was deallocated at the same time, but this is not a major
 issue; the references in the group in question will simply immediately
 tighten again, this time in a smaller group.)
\end_layout

\begin_layout Standard
Unfortunately, this idea has some practical issues preventing it from having
 been fully implemented in Mokapot.
 The issue is that with none of Java's existing reference types being appropriat
e for implementing loose references, some other mechanism is needed to interface
 with Java's garbage collector to determine whether an object is loosely-but-not
-strongly referenced.
 The only real alternative is to make use of a very old (and deprecated)
 garbage collector hook known as 
\family typewriter
finalize
\family default
; this specifies a method that runs (at some time, on some thread) after
 weak references to an object break, but before it is deallocated, with
 the newly unreferenced object as its 
\family typewriter
this
\family default
 pointer (thus, the object is temporarily referenced while the finalizer
 is running, and nothing it references can be fully deallocated until the
 finalizer finishes).
 Unlike weak and phantom references, a finalizer can leave an object referenced
 after it has no remaining strong references; the finalizer simply has to
 store a reference to the object in a field of some object that is strongly
 reachable.
\end_layout

\begin_layout Standard
Finalizers have some issues of their own.
 Most notably, the finalizer has to exist as an actual method on the object
 (which means that the object must belong to a Mokapot-defined class, as
 we cannot change which methods exist on user-defined classes); in practice,
 this means that only objects that were created as standins can be automatically
 migrated.
 (Coincidentally, it's also the case that only objects that were created
 as standins can be manually migrated, for an unrelated reason: preparing
 a migration requires replacing the object with a proxy to that object,
 an operation that requires the object is already a standin to be able to
 implement.) A much more minor issue is that the finalizer for any given
 object can only run once, even if the object becomes unreachable and then
 reachable again; this problem is, however, easy to work around via creating
 a reference cycle between the standin itself, and a small object that exists
 only to store a finalizer.
 (The reference cycle means that the two objects become unreferenced at
 the same time, and also allows the finalizer-bearing object to refer to
 the unreferenced object and store a reference to it elsewhere.
 Then the finalizer-bearing object can simply be destroyed and recreated,
 thus 
\begin_inset Quotes eld
\end_inset

resetting
\begin_inset Quotes erd
\end_inset

 its ability to have its finalizer run.)
\end_layout

\begin_layout Standard
With those caveats in mind, implementing a loose reference to a standin
 via finalizers is fairly simple.
 The loose reference and location manager are in fact the same object (Mokapot
 defines 
\family typewriter
LocationManager
\family default
 as a derived class from 
\family typewriter
LooseTightStandinReference
\family default
).
 The loose/tight reference is effectively a disjoint union, of a weak reference
 that is used while the object is loosely referenced, and a strong reference
 that is used while the object is tightly referenced; and a standin in 
\begin_inset Quotes eld
\end_inset

trivial plus location manager
\begin_inset Quotes erd
\end_inset

 mode has an associated finalizer object (which, to save memory, is the
 same object used internally to indicate that a standin is in this mode).
 When the finalizer runs, it simply puts the location manager into tight
 mode and stores in it a reference to the object that ceased to be strongly
 reachable.
 (This does mean that some periods of time exist during which the location
 manager has no reference to the object, and is waiting for a finalizer
 to run and tell it where the object went.
 Attempts to dereference the location manager in this situation block, and
 send requests to the JVM to increase the effort it spends on running finalizers
; these requests are merged by the same background thread that merges requests
 to run garbage collection.)
\end_layout

\begin_layout Standard
There are two correctness issues in Mokapot's implementation, which were
 sufficient to force the disabling of the automatic migration code.
 One is fairly minor for most programs, but a potential showstopper for
 a subset of them: Java finalizers come between weak and phantom in the
 hierarchy of reference strengths, and thus Mokapot's loose references do
 as well.
 This means that whenever a reference tightens, all weak references to the
 same object are 
\family typewriter
null
\family default
ed out as a side effect.
 This is an observable violation of Java's specification from the point
 of view user's program, and in practice means that weak references cannot
 be used with Mokapot unless the targets of those references are explicitly
 marked as non-migratable.
\end_layout

\begin_layout Standard
The other problem, and the more major one, is that there's no easy way to
 extract the information on which loose references form a group that provide
 access to the same object, and that information is required to be able
 to correctly create a new local reference to an object that was previously
 referenced only remotely.
 There is in theory a mechanism in Java that can be used to deduce this
 information: all weak references in this sort of group are required by
 Java's specification to be nulled atomically, and a weak reference is part
 of the implementation of a loose reference, so if there is ever a time
 at which one of these weak references is observed to be unbroken, and another
 is broken and pointing to 
\family typewriter
null
\family default
, this serves as a guarantee that the two corresponding tight references
 are not part of the same group (and 
\begin_inset Quotes eld
\end_inset

overestimating
\begin_inset Quotes erd
\end_inset

 the size of a group, by merging two groups that have no reason to be merged,
 is inefficient but does not violate correctness rules, so only a one-sided
 guarantee is necessary).
 This mechanism is very difficult to use in practice, though, and Mokapot
 does not attempt to: there is no trigger at the time the weak references
 break to clue Mokapot into knowing the best time to observe them (the breaking
 of references is atomic but the notification of the breaking is asynchronous),
 and typical compacting garbage collector implementations will tend to break
 all the breakable weak references in an object graph infrequently and simultane
ously, leading to the unnecessarily merged groups of tight references being
 much larger than they could be.
 Additionally, although overestimation of a group size does not violate
 correctness, it will cause a quadratic slowdown (
\begin_inset Formula $n$
\end_inset

 groups are unnecessarily merged, we loosen all of them, one group stays
 loose but the other 
\begin_inset Formula $n-1$
\end_inset

 groups all immediately tighten and will probably be incorrectly merged
 again, repeat for 
\begin_inset Formula $n-2$
\end_inset

, 
\begin_inset Formula $n-3$
\end_inset

 etc.
\begin_inset space \space{}
\end_inset

down to 
\begin_inset Formula $1$
\end_inset

).
 So this may well be a problem that is impractical to solve, at least without
 additions to the Java specification.
\end_layout

\begin_layout Part
Evaluation
\end_layout

\begin_layout Section
Limitations
\end_layout

\begin_layout Standard
If it were implemented against an idealized object-oriented language, Mokapot
 would be fully general and capable of handling any program.
 Unfortunately, Java in practice deviates from the idealized language we
 would like to use in several respects, and although Mokapot can work around
 many of these, some of the workarounds are imperfect, and some problems
 cannot be worked around at all.
 As such, there are some cases in which Mokapot either needs additional
 help from the end user to function correctly, or else cannot work at all.
 This section documents the cases in which Mokapot fails, and what remedies
 are available to try to avoid them.
\end_layout

\begin_layout Standard
It should be noted that most of the failure cases do not apply to copiable
 objects: the only potential risks there apply to the moment at which the
 object is copied from JVM to JVM.
 Once a copiable object has been copied, it is accessed locally on each
 JVM that uses it, and being a normal Java object, all the normal mechanisms
 of Java work on it.
 The limitations are thus mostly related to ways in which a standin differs
 from the noncopiable object it stands in for, or situations in which a
 standin cannot be created at all or in which there is nothing to stand
 in for.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:non-overridable"

\end_inset

Method calls that are not overridable
\end_layout

\begin_layout Standard
Mokapot's use of proxies (implemented using standins) effectively makes
 it possible to change the behaviour of an object by changing what methods
 it has; the standin class defines methods of its own that either perform
 proxy functionality, or else delegate to the original methods.
 However, in order for this to work, the code needs to actually call the
 methods of the standin, rather than the original methods; in other words,
 the standin's methods must 
\emph on
override
\emph default
 those of the original object.
\end_layout

\begin_layout Standard
Overriding methods is a standard technique in object-oriented languages,
 and one that Java has extensive support for.
 In Java, overriding methods is done at the class level, via giving a derived
 class a method with the same name and arguments as its superclass; any
 calls to the method via the usual byte-code instructions for method calls,
 
\family typewriter
invokevirtual
\family default
 and 
\family typewriter
invokeinterface
\family default
, will then call the overriding method.
\end_layout

\begin_layout Standard
Unfortunately, there are a few cases in which this can break down.
 One potential issue is that Java has a rarer byte-code instruction, 
\family typewriter
invokespecial
\family default
, to disable method overrides for a single method call.
 The most common use of this is to allow a method of a class to delegate
 to a method of its superclass that it overrides; this mechanism has no
 issues with Mokapot (and is in fact used by Mokapot to implement standins),
 because the method of the standin would override both the calling method
 and called method simultaneously, thus meaning that the existing 
\family typewriter
invokespecial
\family default
 call would only occur in a situation where Mokapot had already decided
 to allow the entire method call to go ahead without further modification.
 However, less common uses of 
\family typewriter
invokespecial
\family default
 are also possible (e.g.
\begin_inset space \space{}
\end_inset

as an optimization to reduce the overhead in a method call that the program
 
\begin_inset Quotes eld
\end_inset

knows will never need to be overridden
\begin_inset Quotes erd
\end_inset

), and these will cause Mokapot to fail.
 Fortunately, these less common uses of 
\family typewriter
invokespecial
\family default
 are not generated by common Java compilers.
\end_layout

\begin_layout Standard
Perhaps a larger issue is that just as method 
\emph on
calls
\emph default
 can be marked as non-overridable using 
\family typewriter
invokespecial
\family default
, a method itself can also be marked as non-overridable using the 
\family typewriter
final
\family default
 keyword, thus making it impossible to implement a standin class that can
 correctly intercept calls to that method.
 This is not a huge problem for methods defined within the user's code,
 as in most cases there is no reason not to simply rewrite the code to remove
 the use of 
\family typewriter
final
\family default
, as it is most commonly used as an optimization rather than anything that
 impacts the correctness of the code.
 In theory, it might be possible to use 
\family typewriter
final
\family default
 as a means to enforce security invariants that could potentially be compromised
 by overriding specific methods, and these invariants would thus be impossible
 to enforce if the code were modified to work with Mokapot, but this sort
 of security model is unlikely to be used in practice.
 It is also probable that there is never a need for it, because the same
 effect could be obtained via inlining (i.e.
\begin_inset space \space{}
\end_inset

copying) the code of the method to each of its call sites.
\end_layout

\begin_layout Standard
The larger problem related to 
\family typewriter
final
\family default
 methods is that there are many uses of them within Java's standard library.
 This means that Mokapot cannot interact correctly with several standard
 library classes, or with user classes that subclass those standard library
 classes.
 However, this is less of an issue than it might appear, as many of the
 classes in question are copiable anyway (thus there is no need to override
 methods on them).
 Still, there are enough noncopiable classes in the standard library that
 their 
\family typewriter
final
\family default
 methods can cause problems.
\end_layout

\begin_layout Standard
Mokapot uses two different techniques to handle this sort of 
\family typewriter
final
\family default
 method.
 One of these is to supply a general workaround: when Mokapot generates
 a standin class that would want to override a particular method (whether
 or not such an override is actually possible), it is also capable of generating
 a second method (whose name is automatically generated based on a simple
 algorithm), which is defined to do what an override of the original method
 should do, if such an override were possible.
 These 
\begin_inset Quotes eld
\end_inset

parallel methods
\begin_inset Quotes erd
\end_inset

 are always overridable (because they are never generated as 
\family typewriter
final
\family default
), so code that would need to call a method that might potentially be 
\family typewriter
final
\family default
 can be modified to call the parallel method instead.
 Unfortunately, Java does not use 
\begin_inset Quotes eld
\end_inset

duck typing
\begin_inset Quotes erd
\end_inset

, i.e.
\begin_inset space \space{}
\end_inset

mere knowledge of a method's existence is not sufficient to get a program
 to type-check, a specification of what class or interface defines the method
 is also necessary.
 To allow for this, Mokapot supports the concept of interfaces that define
 all the parallel methods for methods of a given declaring class; a program
 that takes advantage of parallel methods needs to define the interface
 in question, so that it can call the parallel methods by specifying them
 as belonging to that interface.
 Mokapot will participate in this mechanism via generating the standin to
 support the interface.
 One complication is that the method call might be to an object of the original
 class, not to the standin, and thus a call site will need to check whether
 the parallel method interface is actually implemented by the object in
 question (calling the parallel method via the interface if it is, or the
 original method otherwise).
\end_layout

\begin_layout Standard
The parallel method mechanism is fairly complex, and a larger modification
 to the user's code than most workarounds for limitations.
 Additionally, it does not help for method calls that originate within the
 standard library (unless the standard library itself were modified to use
 parallel methods, but such a modification is not currently planned).
 As such, Mokapot also attempts to make method calls work without overriding,
 in cases where this is possible.
 For example, the method call 
\family typewriter
Thread.join
\family default
, which waits for a thread to exit, is declared as 
\family typewriter
final
\family default
 and thus not overridable.
 However, this method could be made to work by ensuring that the thread
 projection (subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:thread-projections"

\end_inset

) for a given thread, and the standin for the 
\family typewriter
Thread
\family default
 object representing that thread, were the same object, because the thread
 projection exits at the same time the original thread does.
 (This mechanism is not currently implemented in Mokapot, but such a change
 is planned.) The main disadvantage of this sort of change is that it relies
 heavily on reasoning about specific special cases, something that needs
 to be done for each individual method by hand, and is thus time-consuming
 to implement even in the cases where it works (and there are many cases
 where no change of this sort can work).
\end_layout

\begin_layout Standard
There is another potential issue, beyond being 
\family typewriter
final
\family default
, that makes a method impossible to override: being 
\family typewriter
private
\family default
.
 In this case, the method cannot be overridden because a 
\family typewriter
private
\family default
 method cannot be referred to outside its declaring class: an attempt to
 declare a method with the same name and arguments in another class would
 refer to a different method.
 Luckily, in this case, there is normally little need to override the method
 in a standin, because the methods of the original object are only allowed
 to run in the place where that object's data is stored, and thus calls
 from an object's method to another method of the same object are always
 safe, even if overridden.
 The issue here is that although the common use of 
\family typewriter
private
\family default
 is for methods that are only called by other methods of the same 
\emph on
object
\emph default
, which works in Mokapot, 
\family typewriter
private
\family default
 methods are defined in Java to be callable only from other methods of the
 same 
\emph on
class
\emph default
 (and its inner/outer classes).
 Thus, situations in which a method of one object calls a 
\family typewriter
private
\family default
 method of a different object of the same class can fail within Mokapot,
 and are not supported.
 Fortunately, this case is a fairly rare one (and can be fixed via making
 the method package-private instead, potentially renaming it in the process
 in order to avoid naming clashes; the standin is typically in the same
 package as the class it stands in for, and thus can refer to its package-privat
e methods).
\end_layout

\begin_layout Standard
In addition to 
\family typewriter
final
\family default
 methods, Java also supports 
\family typewriter
final
\family default
 classes: classes for which no overriding or subclassing of any sort is
 allowed.
 This sort of class is actually helpful to Mokapot when copiable; as explained
 in subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:serialize-class-name"

\end_inset

, when a field of an object has a declared type that's a 
\family typewriter
final
\family default
 class, this means that the class of any object that might be stored in
 the field is entirely predictable, and thus there's no overhead in sending
 information about that class over the network.
 It is, however, much less helpful when the class is noncopiable, because
 it makes it impossible for a standin to belong to a class that extends
 the object's class, and thus a field or variable whose declared type is
 the object's actual class could never be used to store a standin object.
\end_layout

\begin_layout Standard
There is probably no perfect solution to the problem of 
\family typewriter
final
\family default
 classes within the Java standard library (of course, for noncopiable 
\family typewriter
final
\family default
 classes within the user's code, the problem can be fixed simply by removing
 the 
\family typewriter
final
\family default
 modifier).
 However, for many of these classes, the class itself is highly specific,
 e.g.
\begin_inset space \space{}
\end_inset

the class is a particular implementation of some interface or container
 class; in fact, 
\family typewriter
final
\family default
 classes are often non-
\family typewriter
public
\family default
, used to implement the output of factory methods that merely ask for an
 object that fits a particular description.
 In such cases, code which uses objects of the class in question would typically
 not refer to the exact specific class that the object is expected to have,
 but be written in a more general way, listing a superclass or interface
 that the object would be expected to conform to.
 As such, Mokapot's workaround for 
\family typewriter
final
\family default
 classes is to generate standins that, rather than overriding the class
 itself, override the class's superclass and implement all the same interfaces.
 (The superclass of a class can never be 
\family typewriter
final
\family default
, because 
\family typewriter
final
\family default
 classes disallow subclassing and thus the class itself could not have been
 defined.) This workaround works in all cases except those where the 
\family typewriter
final
\family default
 class is named specifically as being required at a particular point in
 the code, something which would be bad Java style and thus is fairly rare.
 The unsolvable case does at least give clear symptoms at runtime, leading
 to a 
\family typewriter
ClassCastException
\family default
 when the object is stored into a variable that requires a more specific
 class than it can have.
\end_layout

\begin_layout Standard
The standard library also has a related issue of its own.
 Some of the packages implemented by the standard library, such as 
\family typewriter
java.lang
\family default
, are defined as being implementable 
\emph on
only
\emph default
 by the standard library.
 This causes problems when an attempt is made to create a standin for a
 class that belongs to such a package: normally standins are created in
 the same package as the class they stand in for (so that they can use a
 package-private class as a superclass, and override package-private methods
 of the class), but this is impossible for classes in 
\family typewriter
java
\family default
.
\family typewriter
lang
\family default
.
 The best Mokapot can do in such cases is to generate the standin in a different
 package (if the class is 
\family typewriter
public
\family default
) or treat the class as though it were 
\family typewriter
final
\family default
 (if the class is not 
\family typewriter
public
\family default
), something which is obviously not fully general because package-private
 methods will not be proxied correctly.
 However, this workaround normally works in practice (especially because
 classes that are package-private to the standard library are rarely named
 directly; the standard library rarely does this, and a user's code 
\emph on
cannot
\emph default
 do this).
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:not-methods"

\end_inset

Accesses to objects that are not method calls
\end_layout

\begin_layout Standard
[this section follows a logical train of thought, but I'm not happy with
 the subsectioning / breaks / etc.
\begin_inset space \space{}
\end_inset

because all the sections overlap rather than being neatly separable; right
 now it's just a long list of paragraphs but I suspect that needs changing]
\end_layout

\begin_layout Standard
The idealized object-oriented language that forms the basis of Mokapot's
 design uses method calls for everything, thus allowing proxies to be implemente
d by overriding the method calls.
 The previous subsection discusses situations in which Mokapot fails because
 those method calls cannot be overridden.
 However, Java presents a second problem: it provides ways to interact with
 objects other than the use of method calls.
 These non-method accesses to objects cannot be overridden, and thus will
 produce invalid results when used on Mokapot's standins.
\end_layout

\begin_layout Standard
One of the most commonly used of these is the reference equality operator,
 
\family typewriter
==
\family default
.
 (Objects in Java can be compared either by reference or by value; the value
 comparison uses a method 
\family typewriter
.equals()
\family default
, which is normally overridable, but the reference comparison is a built-in
 operator whose definition cannot be changed.) Thus, the Java program will
 see two objects as being the same object in memory if and only if they're
 represented by the same Java object in memory, and there is no way to change
 that.
 Fortunately, the main use of 
\family typewriter
==
\family default
 is on objects that can be mutated; if objects are immutable, you normally
 don't care about whether two indistinguishable objects are the same object
 or copies of each other, but if objects are mutable, the distinction matters
 because it will affect what happens if one of the objects is mutated.
 Mutable objects are basically always noncopiable, and it turns out that
 
\family typewriter
==
\family default
 automatically does the right thing with most noncopiable objects: Mokapot
 will not simultaneously create two standins for the same object on the
 same JVM (because an object's standin is cached in its location manager
 until it is deallocated), so any 
\family typewriter
==
\family default
 that 
\begin_inset Quotes eld
\end_inset

should
\begin_inset Quotes erd
\end_inset

 return 
\family typewriter
true
\family default
 can only end up reference-comparing the standin for equality with itself.
 Of course, this could lead to trouble if both a standin for an object,
 and the object itself, end up on the same JVM.
 Mokapot aims to avoid this by preventing standins from ever becoming visible
 to user code when the 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 object that they stand in for exists on the same JVM (it can use standins
 internally to make use of generated code for serialization, but will not
 use their functionality as standins).
 The main drawback of this is that objects cannot be migrated unless they
 were created as standins, or it is known that no existing local references
 to them exist.
\end_layout

\begin_layout Standard
There are a couple of other ways in which this can fail, too.
 One issue relates to objects which are copiable, but where 
\family typewriter
==
\family default
 is used on them anyway: Mokapot makes no attempt to keep only one copy
 of copiable objects, so a copiable object that is passed back and forth
 between two JVMs will be copied every time.
 If the user's code attempts to reference-compare two of these copies, they
 will compare unequal even though they would have compared equal if Mokapot
 were not used.
 This behaviour is permitted by the definition of copiable objects, 
\begin_inset Quotes eld
\end_inset

a reference to a copiable object can be replaced by a reference to a copy
 of it without changing the semantics of the program
\begin_inset Quotes erd
\end_inset

, so is fine in the case where the user explicitly writes 
\family typewriter
implements Copiable
\family default
 in their code.
 More commonly, though, objects will be interpreted as copiable as a consequence
 of heuristics (such as having no mutable fields), and these heuristics
 will sometimes see an object as copiable when its identity is actually
 relevant.
 This thus creates a limitation that immutable objects for which false negatives
 for 
\family typewriter
==
\family default
 are unacceptable must be explicitly marked as 
\family typewriter
implements NonCopiable
\family default
.
 (This limitation is, however, rarely relevant in practice, as the most
 common use for 
\family typewriter
==
\family default
 on immutable objects is as an optimization when checking for value equality,
 as two objects that are reference-equal should not be value-unequal.
 A false positive on this would be problematic, but a false negative has
 no correctness implications, merely a small performance loss.) Mokapot also
 has a special case to treat as noncopiable objects of class 
\family typewriter
java.lang.Object
\family default
 (i.e.
\begin_inset space \space{}
\end_inset

that are instances of the universal base class itself, rather than belonging
 to a subclass of it); despite being immutable (and in fact containing no
 data at all), such objects are only useful for their identities (most commonly
 
\family typewriter
==
\family default
 comparisons), so copying them is unlikely to preserve the program's semantics.
\end_layout

\begin_layout Standard
The other possible failure is in a situation where a standin exists on a
 JVM, and then its referent 
\begin_inset Quotes eld
\end_inset

leaks
\begin_inset Quotes erd
\end_inset

 from inside the standin and ends up being referenced on the same JVM as
 the standin.
 In this undesirable situation, most uses of the object will continue to
 work as normal (although migration will malfunction, because references
 to the standin and references to the referent will end up referring to
 different objects after the migration).
 However, 
\family typewriter
==
\family default
 comparisons between the standin and its referent will return 
\family typewriter
false
\family default
 (when without Mokapot, the same program would return 
\family typewriter
true
\family default
).
 Mokapot does not currently make any attempt to prevent this happening (although
 it does try to use standins that are their own referent whenever possible,
 a choice made for other reasons but which has the side effect of preventing
 this situation occurring via eliminating any distinction between standin
 and standin referent).
\end_layout

\begin_layout Standard
Oddly, reference equality is not the only form of equality that has problems:
 value equality has some issues of its own.
 Although 
\family typewriter
.equals()
\family default
 is a method, and thus Mokapot can override it (as long as there are no
 issues with finality), Mokapot's overrides eventually work by finding the
 original object (on whatever JVM it's currently on) and calling the method
 there.
 Thus, an attempt to compare two objects that currently reside on different
 JVMs using 
\family typewriter
.equals()
\family default
 will inevitably end up running the method on one, giving it a proxy to
 the other as its parameter.
 This means that any operations performed within 
\family typewriter
.equals()
\family default
 have to be operations that are correct when performed on proxies, i.e.
\begin_inset space \space{}
\end_inset

overridable method calls.
\end_layout

\begin_layout Standard
Unfortunately, there's one operation in Java that's very uncommon in general,
 but very common in implementations of 
\family typewriter
.equals()
\family default
: directly accessing the fields of another object.
 Object fields are used to store data, and in nearly every case, those fields
 are read and written via 
\begin_inset Quotes eld
\end_inset

getter
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

setter
\begin_inset Quotes erd
\end_inset

 methods that abstract away the low-level details of how the data is stored.
 This has the advantage for the programmer that they can change the low-level
 details without breaking existing code, or extend a class to store things
 differently and automatically allow code that was written to work with
 objects of that class to work with the extending class too.
 It also has an advantage for Mokapot, in that it can override the getter
 and setter methods to make the field accesses work even cross-JVM.
 However, it is theoretically possible for an object to read or write a
 field of another object directly, without going via the getter and setter
 methods.
 It is considered good Java style to mark fields as 
\family typewriter
private
\family default
, so this is only possible when the two objects belong to the same class;
 but nothing prevents one object of a class from directly reading the fields
 of another object of that class.
\end_layout

\begin_layout Standard
This sort of cross-object direct field access makes it almost impossible
 to maintain encapsulation (i.e.
\begin_inset space \space{}
\end_inset

the ability to change low-level details in one part of the code without
 affecting other code that operates on a higher level); in order to perform
 such an access in a future-proof manner, you would need to be sure that
 the two objects belonged to 
\emph on
exactly
\emph default
 the same class (having a common superclass is not enough).
 The only commonly seen place where this happens is in value equality comparison
s, which normally start by checking that the two objects being compared
 have an identical class (if they don't, the two objects are considered
 value-unequal).
 Having checked that, it's very common for code to then switch to the faster
 direct field access, rather than using getter methods (which are slower
 if the Java compiler, and the JVM's just-in-time compiler, fail to optimize
 them out).
 Unfortunately, Mokapot cannot do anything to intercept this, and if two
 objects on different JVMs are compared using 
\family typewriter
.equals()
\family default
, the fields of one object will end up being compared to the fields of a
 standin for the other object, which are quite possibly entirely unused,
 containing dummy data.
 The check is therefore highly likely to return 
\family typewriter
false
\family default
, even when it should return 
\family typewriter
true
\family default
.
 (
\family typewriter
.equals()
\family default
 also has a second problem: the class comparison itself normally uses 
\family typewriter
getClass
\family default
(), which is a non-overridable method, and would return the standin class
 for a standin rather than the class of the referent.
 This issue can be worked around in the same ways as with other non-overridable
 methods, though.)
\end_layout

\begin_layout Standard
There is probably no general solution to the issues with 
\family typewriter
.equals()
\family default
, but it can often be worked around in a fairly simple way: just as 
\family typewriter
==
\family default
 fails with copiable objects, and this can be fixed by explicitly marking
 them noncopiable, typical implementations of 
\family typewriter
.equals()
\family default
 fails with noncopiable objects but can be fixed by marking them as copiable.
 That said, this cannot be a fully general fix, because the object might
 not be semantically copiable.
 In most cases, though, it will be: value equality of mutable objects is
 a fairly weird concept, given that whether the two objects are equal or
 not can change over time, a fact that violates the invariants that you
 would normally want from an equality operation.
\end_layout

\begin_layout Standard
In addition to 
\family typewriter
.equals()
\family default
, there is one other common case in which an object's internal data is accessed
 directly: the Java array.
 Arrays are unusual in that despite being objects, they do not and cannot
 have methods: rather, they have a set number of elements (chosen when the
 array is constructed), which act much like fields (except that they are
 selected using indices that can be calculated at runtime, rather than needing
 to be hard-coded into the program).
 Because there are no getter methods to get at array elements, the elements
 thus need to be accessed directly, and so in practice act as though they
 were 
\family typewriter
public
\family default
 fields, and are generally accessed with no encapsulation at all.
 This is one of the worst possible situations for Mokapot because there's
 nothing to override in order to allow for a standin (and thus a proxy)
 for an array to be created: any code that's designed to access an array
 will only ever access an array on the local JVM.
 Unlike with most objects, there's no special sort of parameter you can
 give it that will cause the accesses to magically cross a network.
\end_layout

\begin_layout Standard
There is only one attempt Mokapot can make as an automatic solution to this
 issue, and thus it adopts it: arrays are treated as copiable, not because
 doing so is semantically correct (arrays are mutable and often mutated
 in practice), but because there is no possible way to treat them as noncopiable.
 Thus, any attempt to mention an array on another JVM will cause the entire
 array to be copied from one JVM to another.
 In many cases, this solution works, because the array happens to never
 be mutated after it was shared between multiple JVMs (due to Java's very
 restricted set of primitives, arrays are a very common choice for the backing
 storage of data structures, even those which never change after creation;
 thus Java arrays are often immutable in practice too).
 However, if the array is mutated once it becomes referenced from multiple
 JVMs, there is no automatic way that Mokapot can propagate changes made
 on one JVM to the others.
\end_layout

\begin_layout Standard
Instead, more manual solutions need to be found.
 The most promising, and something that can often be accomplished mechanically,
 is to replace arrays with lists.
 Unlike arrays, Java lists use getter and setter methods to retrieve and
 store data; most classes of list are also fully overridable.
 List-using code is normally written to be polymorphic to arbitrary list
 classes, too, which makes creating standins for them easy.
 When the code can be changed, therefore, array-to-list replacement is effective
ly a perfect solution for the issues with arrays.
\end_layout

\begin_layout Standard
The main issue with this is that not all code that uses arrays can be changed
 by the user: in particular, arrays are frequently used as arguments to
 and return values from standard library methods, and sometimes even used
 as fields of standard library objects that need to be passed to such methods.
 Assuming that the user is unwilling or unable to change the Java standard
 library's calling conventions, an array thus needs to be created 
\begin_inset Quotes eld
\end_inset

on the spot
\begin_inset Quotes erd
\end_inset

 to provide as an argument to the method.
 This is fairly easy (if inefficient) in cases where the array is simply
 used as an input argument to the standard library method, and not mutated,
 as it is possible to simply make an array as a copy of the list.
 However, if the standard library method mutates the array, it is then necessary
 to copy the new value of the array back into the list after the method
 has been called.
 These steps get even more complex if the array is not directly a parameter
 to the method, but rather referred to indirectly via some other object.
 At present, there is not a reliable solution to this problem.
\end_layout

\begin_layout Standard
One final type of access to objects, other than reference equality, direct
 field access, and array element access, is access to an object's 
\emph on
monitor
\emph default
.
 All objects in Java have a monitor, which is basically a lock combined
 with a condition variable (which allows a holder of the lock to temporarily
 suspend its hold on the lock to allow some other thread to lock the same
 monitor, and later re-take the lock in a thread-safe way).
 It is rare for any particular object's monitor to be used, but multi-threaded
 Java programs will often make use of a few monitors, either directly or
 indirectly, in order to gain thread-safety.
 (Just as arrays are the primitives from which data structures are typically
 built in Java, monitors are the primitives from which synchronization primitive
s are built.) From Mokapot's point of view, a monitor is highly similar to
 a field: an object can directly access its own monitor without issues (just
 like it can directly access its own fields without issues), because the
 issues only arise from cross-JVM accesses and an object is always on the
 same JVM as itself.
 However, if one object accesses a monitor of another object directly, there
 is no longer a guarantee that the objects exist on the same JVM, and in
 particular it is quite likely that the monitor that is locked (or waited
 on) will be the monitor of a standin, rather than the monitor of the original
 object.
 This is a particular problem as it can lead to subtle race conditions,
 due to the locks within monitors becoming lockable once per JVM that exists
 within the computation, rather than once across the computation as a whole,
 thus is hard to diagnose.
 Exacerbating this further is the issue that monitors cannot be 
\family typewriter
private
\family default
 or 
\family typewriter
protected
\family default
; they are as globally-usable as a 
\family typewriter
public
\family default
 method, and accessing an unrelated object's monitor is a common operation
 in practice (to the extent that it is often unwise for an object to refer
 to its own monitor in case some other object is using that monitor for
 some other purpose).
\end_layout

\begin_layout Standard
[credit Thomas for this, somehow? he discovered what was going on here,
 not me, and I'm not sure I understand the details] Just as with direct
 field access, direct access to another object's monitor is unfixable from
 within Mokapot itself, and thus in any situation where it could happen
 cross-JVM, the issue needs to be resolved via changes to the user's code.
 There are two obvious ways in which this change could be made, each of
 which has issues of its own.
\end_layout

\begin_layout Standard
One possibility is to automatically forward any monitor operations across
 the network: for example, instead of locking a monitor's lock locally,
 you could check where the monitor is at the moment, and then send a request
 to lock the lock in question across the network to that JVM and lock it
 there.
 This means that only a single monitor (the monitor of the original object)
 is being used for all monitor operations, thus preserving the semantics
 of the original code.
 Unfortunately, there is one major issue with this solution: although it
 would work if it could be implemented, it is tedious to do manually and
 difficult to do in an automated way.
 The problem is that the JVM checks, via static analysis when loading the
 byte-code of the program it is executing, that monitor lock and unlock
 operations are always well-nested and correctly paired.
 This check is very helpful in preventing accidental double-unlocks or leaked
 locks, but has the unfortunate side effect of making it impossible to lock
 and unlock an object based on 
\begin_inset Quotes eld
\end_inset

lock
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

unlock
\begin_inset Quotes erd
\end_inset

 instructions received across a network (because the JVM's static analysis
 obviously does not extend to network packets that will be received during
 the program's lifetime).
 As such, instead of forwarding 
\begin_inset Quotes eld
\end_inset

lock
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

unlock
\begin_inset Quotes erd
\end_inset

 instructions across the network, the whole 
\begin_inset Quotes eld
\end_inset

lock, do things, unlock
\begin_inset Quotes erd
\end_inset

 sequence would need to be forwarded, and this does not exist in an easily
 extractable form within the Java program: any compiler that does this would
 need to repeat the same static analysis that the JVM does.
\end_layout

\begin_layout Standard
The other possibility is to replace use of monitors with use of separate
 
\family typewriter
Lock
\family default
 and 
\family typewriter
Condition
\family default
 objects (an operation analogous to replacing arrays with lists).
 The issue with this is the same as the issue with array-with-list replacement:
 sometimes the Java standard library's API relies specifically on the use
 of a monitor, and will not accept more modern alternatives.
 Thus, although automated replacement of monitors with 
\family typewriter
Lock
\family default
/
\family typewriter
Condition
\family default
 is possible and fairly easy, the resulting programs tend to malfunction
 in practice.
\end_layout

\begin_layout Standard
The best known solution to this is a mix of the two solutions: using a separate
 
\family typewriter
Lock
\family default
 object to replace the lock part of the monitor, but the monitor's built-in
 condition variable rather than a 
\family typewriter
Condition
\family default
 object.
 Although mixing concurrency primitives in this way is often dangerous or
 at least hard to reason about, it appears to be safe in this case because
 it is possible to write the relevant algorithms such that the 
\family typewriter
Lock
\family default
 object is always held at the moment the monitor's lock is taken, giving
 a lock order policy that prevents deadlocks, and because there is no actual
 need for the operation of 
\begin_inset Quotes eld
\end_inset

ceasing to wait on a condition variable
\begin_inset Quotes erd
\end_inset

 to re-take the lock immediately (you can wait indefinitely for the lock
 to become available without changing the semantics of the program).
 When the Java standard library uses the object of a monitor as input, it
 is typically for the condition variable rather than for the lock itself,
 so this method is sufficiently cooperative with the library to function.
 Additionally, there is no requirement for condition variable operations
 to be well-nested (such a requirement would probably be meaningless in
 any case), so they can be forwarded across the network even though the
 corresponding lock operations cannot be.
\end_layout

\begin_layout Subsection
State that cannot be preserved cross-JVM
\end_layout

\begin_layout Standard
In most cases, the semantics of Java code do not depend on which JVM it
 is run on, a fact Mokapot takes advantage of when implementing noncopiable
 objects (by executing their methods on the same JVM where they are stored).
 In some cases, however, this assumption does not hold, and causes Mokapot
 to fail as a consequence.
\end_layout

\begin_layout Standard
One of the more obvious situations in which this can occur is if the JVMs
 that make up the computation do not contain the same set of classes; if
 a class is defined differently on two JVMs, then a use of it on one JVM
 may have a different meaning on the others.
 Mokapot, therefore, requires all the JVMs involved to have the identical
 class-paths.
 However, this requirement goes further: in Java, it is fairly common to
 generate classes at runtime, but these generated classes will be loaded
 into only a single JVM, and missing on the others.
 As such, any attempt to use generated classes will fail with Mokapot unless
 the classes are copied (at runtime) onto the other JVMs involved in the
 computation.
 This is something that it is hard for Mokapot to automate a fix to: although
 it can determine that a class is present on one JVM but missing on the
 others, the Java standard library does not contain a method that could
 determine what code a generated class contains, so the remote JVM could
 not be told what class to load.
 The problem may be fixable on a case-by-case basis (e.g.
\begin_inset space \space{}
\end_inset

by explicitly notifying Mokapot that a class has been generated, and specifying
 the byte-code of the new class), but this is not something that Mokapot
 attempts to handle at present, except in the case of serializable lambda
 classes.
\end_layout

\begin_layout Standard
The issue with lambda classes is that uses of a lambdas within a program
 are compiled into 
\family typewriter
invokedynamic
\family default
 byte-code instructions; when these are executed for the first time, they
 generate a new lambda class (and permanently link themselves to its constructor
, so that future uses will use the same class).
 This mechanism is something that it is hard to get introspection into from
 within Mokapot; it can determine that a lambda class has been generated,
 but it is hard in the general case to determine anything else about the
 class.
\end_layout

\begin_layout Standard
As such, any lambdas used with Mokapot need to be declared to implement
 the standard library interface 
\family typewriter
java.io.Serializable
\family default
.
 This is a marker interface that specifies that the object should be supported
 by the Java standard library's serialization routines.
 Although Mokapot does not actually use these routines, it causes the lambda
 generation code to see that the lambda might need to be transferred onto
 another JVM, and it generates a serialization hook (a method named 
\family typewriter
writeReplace
\family default
) that transforms the lambda into an object describing that lambda.
 These descriptions (of class 
\family typewriter
java.lang.invoke.SerializedLambda
\family default
) have a 
\family typewriter
readResolve
\family default
 method that can be used to recreate the original lambda – and because it
 is possible that the first lambda of a given class on a given JVM is created
 via 
\family typewriter
readResolve
\family default
 rather than 
\family typewriter
invokedynamic
\family default
, it creates the lambda class itself if it is missing.
 The 
\family typewriter
SerializedLambda
\family default
 + 
\family typewriter
readResolve
\family default
 mechanism therefore makes it possible for Mokapot to recreate serializable
 lambdas on a remote JVM, and Mokapot's special case for generated lambdas
 does precisely this.
 However, Mokapot cannot currently handle any other cases of generated classes,
 including non-serializable lambdas.
\end_layout

\begin_layout Standard
Classes are an example of something that exists separately on each JVM,
 but do not necessarily have to match on every JVM.
 A much more obscure part of Java that acts like this is the enumeration
 constant.
 An 
\family typewriter
enum
\family default
 class is effectively implemented as a class which has a fixed number of
 instances, created by the class's static initializer; in typical usage
 (which Mokapot assumes), every object of the class will be one of those
 instances, the class's enumeration constants.
 It therefore makes sense to talk about 
\begin_inset Quotes eld
\end_inset

a particular enumeration constant
\begin_inset Quotes erd
\end_inset

 of a class (using, e.g.,
\begin_inset space \space{}
\end_inset

its name or index number).
 When Mokapot needs to send an enumeration constant from one JVM to another,
 it simply sends its class and index number, on the basis that the same
 set of enumeration constants should have been created on every JVM involved
 in the computation.
\end_layout

\begin_layout Standard
Unfortunately, there is a corner case that causes this simple algorithm
 to fail.
 Although on each JVM, the list of enumeration constants of a given 
\family typewriter
enum
\family default
 class should have been created identically, Java does not place any safeguards
 against mutating an enumeration constant after it has been created.
 If such a mutation happens on one JVM involved in the computation, the
 mutation will not propagate to other JVMs, and this will change the semantics
 of the program.
 Luckily, the mutation of enumeration constants is a rarely used corner
 of Java, and the fact that Mokapot cannot handle it is thus unlikely to
 cause problems in practice.
\end_layout

\begin_layout Standard
A more common example of JVM-specific state is that of a 
\family typewriter
static
\family default
 field.
 These fields are not associated with any given object, and exist as one
 copy in each JVM.
 Just like the enumeration constants, they can therefore be mutated separately
 on each JVM, altering the semantics of the program.
 Mokapot's current attitude with these is to treat this as an opportunity,
 rather than a problem: it allows the user to specify which particular copy
 of a 
\family typewriter
static
\family default
 field they wish to use, allowing them to be used as a mechanism to communicate
 between unrelated threads.
 (If the user does not specify, the 
\family typewriter
static
\family default
 field from the same JVM as the currently executing method is used, partly
 as a sensible default but mostly because Mokapot has no way to override
 this.) Nonetheless, this behaviour can lead to trouble in cases where a
 
\family typewriter
static
\family default
 field is intended to be truly global; if a user does not explicitly specify
 the use of the same copy of it every time, the assumptions on which the
 program is based may be violated.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
[do we have any of these yet? it's still a bit early, Mokapot hasn't been
 used for much; Millr is probably better mentioned here than in the previous
 chapter]
\end_layout

\end_body
\end_document

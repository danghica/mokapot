package xyz.acygn.mokapot.test.bytecode;

import java.io.DataOutput;
import java.io.IOException;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.function.Consumer;
import xyz.acygn.mokapot.markers.DistributedError;
import xyz.acygn.mokapot.skeletons.Authorisation;
import xyz.acygn.mokapot.skeletons.ForwardingStandinStorage;
import xyz.acygn.mokapot.skeletons.ProxyOrWrapper;
import xyz.acygn.mokapot.skeletons.Standin;
import xyz.acygn.mokapot.skeletons.StandinStorage;
import xyz.acygn.mokapot.skeletons.TrivialStandinStorage;
import xyz.acygn.mokapot.wireformat.DescriptionOutput;
import xyz.acygn.mokapot.wireformat.ObjectDescription;
import xyz.acygn.mokapot.wireformat.ReadableDescription;

/**
 * An inheritance-based standin for <code>TrivialTestClass</code>. This was
 * written by hand; the idea is that the bytecode for this can be compared to
 * generated bytecode to check for any mistakes.
 *
 * @author Alex Smith
 */
public class TrivialTestClassStandin extends TrivialTestClass
        implements Standin<TrivialTestClass> {

    /**
     * The data storage for this test class.
     */
    private StandinStorage<TrivialTestClass> storage;

    /**
     * Instantiates a new TrivialTestClass standin object directly via the use
     * of its constructor.
     *
     * @param data The data to store in the new object.
     */
    public TrivialTestClassStandin(int data) {
        super(data);
        storage = new TrivialStandinStorage<>();
    }

    @Override
    public Class<TrivialTestClass> getReferentClass(
            ProxyOrWrapper.Namespacer dummy) {
        return TrivialTestClass.class;
    }

    @Override
    public StandinStorage<TrivialTestClass> getStorage(Authorisation auth) {
        return storage;
    }

    @Override
    public void setStorage(StandinStorage<TrivialTestClass> storage,
            Authorisation auth) {
        auth.verify();
        this.storage = storage;
    }

    @Override
    public ObjectDescription.Size descriptionSize(Authorisation auth) {
        return new ObjectDescription.Size(4, 0);
    }

    @Override
    public void writeTo(DataOutput sink, Authorisation auth)
            throws UnsupportedOperationException {
        throw new UnsupportedOperationException(
                "TrivialTestClass is not deeply copiable");
    }

    @Override
    public void describeInto(DescriptionOutput desc, Authorisation auth)
            throws IOException {
        auth.verify();
        desc.writeInt(this.getData());
    }

    @Override
    public void replaceWithReproduction(Class<TrivialTestClass> referentClass,
            ReadableDescription desc, Authorisation auth) throws IOException {
        Consumer<Object> setter = getSettingConsumerForReferent(auth);
        setter.accept(desc.readInt());
    }

    @Override
    @SuppressWarnings({"NotifyNotInSynchronizedContext", "WaitWhileNotSynced"})
    public Object invoke(long methodCode, Object[] methodArguments,
            Authorisation auth) throws Throwable {
        auth.verify();
        switch ((int) methodCode) {
            case 0xe531f10d:
                return super.toString();
            case 0x9a34d1c9:
                return super.clone();
            case 0xa0bdd7b2:
                return super.dataEquals((int) methodArguments[0]);
            case 0x85e26120:
                return super.hashCode();
            case 0x65e16164:
                return super.equals(methodArguments[0]);
            case 0x355ab1e2:
                return super.getData();
            case 0x54d68245:
                super.notify();
                return null;
            case 0x44ac6988:
                super.wait();
                return null;
            case 0xe014c578:
                super.wait((long) methodArguments[0]);
                return null;
            case 0x5597729f:
                /* super.getClass(); we can hardcode this output! */
                return TrivialTestClass.class;
            case 0x8e7a9f42:
                super.notifyAll();
                return null;
        }
        throw new DistributedError(new NoSuchMethodException(),
                "Cannot invoke method, no method with method code "
                + methodCode);
    }

    @Override
    public TrivialTestClass getReferent(Authorisation auth) {
        auth.verify();
        return this;
    }

    @Override
    public boolean dataEquals(int data) {
        if (storage instanceof ForwardingStandinStorage) {
            try {
                return (boolean) ((ForwardingStandinStorage) storage).
                        forwardMethodCall(0xe05dda8ca0bdd7b2L, new Object[]{data});
            } catch (RuntimeException | Error ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new UndeclaredThrowableException(ex);
            }
        }
        return super.dataEquals(data);
    }

    @Override
    public int getData() {
        if (storage instanceof ForwardingStandinStorage) {
            try {
                return (int) ((ForwardingStandinStorage) storage).
                        forwardMethodCall(0x2cd87cb7355ab1e2L, new Object[]{});
            } catch (RuntimeException | Error ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new UndeclaredThrowableException(ex);
            }
        }
        return super.getData();
    }

    @Override
    public String toString() {
        if (storage instanceof ForwardingStandinStorage) {
            try {
                return (String) ((ForwardingStandinStorage) storage).
                        forwardMethodCall(0xbab521f6e531f10dL, new Object[]{});
            } catch (RuntimeException | Error ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new UndeclaredThrowableException(ex);
            }
        }
        return super.toString();
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        if (storage instanceof ForwardingStandinStorage) {
            try {
                return ((ForwardingStandinStorage) storage).
                        forwardMethodCall(0xb4d61cc79a34d1c9L, new Object[]{});
            } catch (RuntimeException | Error | CloneNotSupportedException ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new UndeclaredThrowableException(ex);
            }
        }
        return super.clone();
    }

    @Override
    public boolean equals(Object obj) {
        if (storage instanceof ForwardingStandinStorage) {
            try {
                return (boolean) ((ForwardingStandinStorage) storage).
                        forwardMethodCall(0x1ea13dfa65e16164L, new Object[]{obj});
            } catch (RuntimeException | Error ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new UndeclaredThrowableException(ex);
            }
        }
        return super.equals(obj);
    }

    @Override
    public int hashCode() {
        if (storage instanceof ForwardingStandinStorage) {
            try {
                return (int) ((ForwardingStandinStorage) storage).
                        forwardMethodCall(0x2b95c87d85e26120L, new Object[]{});
            } catch (RuntimeException | Error ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new UndeclaredThrowableException(ex);
            }
        }
        return super.hashCode();
    }

}

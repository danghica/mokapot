package xyz.acygn.mokapot;

import java.io.DataOutput;
import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import static xyz.acygn.mokapot.ClassKnowledge.knowledgeForClass;
import xyz.acygn.mokapot.skeletons.Authorisation;
import xyz.acygn.mokapot.skeletons.ProxyOrWrapper;
import xyz.acygn.mokapot.skeletons.Standin;
import xyz.acygn.mokapot.skeletons.StandinStorage;
import xyz.acygn.mokapot.skeletons.TrivialStandinStorage;
import xyz.acygn.mokapot.util.DataByteBuffer;
import xyz.acygn.mokapot.wireformat.DescriptionOutput;
import xyz.acygn.mokapot.wireformat.ObjectDescription;
import xyz.acygn.mokapot.wireformat.ReadableDescription;

/**
 * Inheritance-based standin for <code>MarshalledDescription</code>. This is a
 * special case due to containing a byte buffer (which is in general very
 * noncopiable), yet the class as a whole is copiable anyway. As such, some of
 * the standin needs to be written by hand, rather than autogenerated as usual.
 * <p>
 * The precise layout of this class does not follow the normal conventions (due
 * to the need to change how the byte buffer works), and instead looks like
 * this, in order:
 * <ul>
 * <li>A ReferenceValue array (marshalled in the normal way)</li>
 * <li>The number of bytes in the byte buffer</li>
 * <li>The content of the byte buffer</li>
 * <li>Whether the buffer is read-only</li>
 * </ul>
 * <p>
 * This class also serves as an example of what an inheritance-based standin
 * class for a copiable object typically looks like.
 *
 * @author Alex Smith
 */
class MarshalledDescriptionStandin extends MarshalledDescription
        implements Standin<MarshalledDescription> {

    /**
     * The class knowledge for an array of <code>ReferenceValue[]</code>
     * objects. This is commonly used (thus is worth storing in a static
     * variable), and it's also worth centralising the definition in one place
     * so that the long casts needed to make it work don't need to be written
     * out every time.
     */
    @SuppressWarnings("unchecked")
    private static final ClassKnowledge<ReferenceValue<?>[]> RV_ARRAY_KNOWLEDGE
            = knowledgeForClass(
                    (Class<ReferenceValue<?>[]>) (Class<?>) ReferenceValue[].class);

    /**
     * Reflective handles to the fields of this class, mapped to their names.
     * Used to get around the <code>private</code> and <code>final</code>
     * modifiers on this class's fields.
     */
    private static final Map<String, Field> FIELD_MAP;

    static {
        FIELD_MAP = new HashMap<>();
        for (Field field : knowledgeForClass(
                MarshalledDescription.class).getInstanceFieldList()) {
            FIELD_MAP.put(field.getName(), field);
        }
    }

    /**
     * Pass-through constructor. Creates a standin
     * <code>MarshalledDescription</code> the same way that its constructor
     * creates a regular <code>MarshalledDescription</code>.
     *
     * @param description The description to marshal.
     * @param sourceCommunicator The communicator on which the original object
     * is being marshalled.
     * @param targetSystem The system which will unmarshal the resulting
     * standin. Can be <code>null</code> in the case that the description in
     * question is of a deeply copiable object.
     */
    MarshalledDescriptionStandin(
            ObjectDescription description,
            DistributedCommunicator sourceCommunicator,
            CommunicationAddress targetSystem) {
        super(description, sourceCommunicator, targetSystem);
    }

    /**
     * Creates a marshalled description standin from its individual components.
     * Used during deserialisation.
     *
     * @param marshalledNoncopiableObjects The marshalled form of noncopiable
     * objects that are contained in the description.
     * @param byteBuffer The marshalled form of copiable objects that are
     * contained in the description.
     * @param objectsCursor The initial location of the noncopiable objects
     * cursor.
     */
    private MarshalledDescriptionStandin(
            ReferenceValue<?>[] marshalledNoncopiableObjects,
            DataByteBuffer byteBuffer, int objectsCursor) {
        super(marshalledNoncopiableObjects, byteBuffer, objectsCursor);
    }

    @Override
    public Class<MarshalledDescription> getReferentClass(
            ProxyOrWrapper.Namespacer dummy) {
        return MarshalledDescription.class;
    }

    @Override
    public StandinStorage<MarshalledDescription> getStorage(Authorisation auth) {
        return new TrivialStandinStorage<>();
    }

    @Override
    public void setStorage(StandinStorage<MarshalledDescription> storage,
            Authorisation auth) {
        throw new UnsupportedOperationException(
                "Cannot set storage for a Copiable standin");
    }

    @Override
    public ObjectDescription.Size descriptionSize(
            Authorisation auth) {
        auth.verify();
        return RV_ARRAY_KNOWLEDGE.descriptionSize(
                () -> getMarshalledNoncopiableObjects(), false)
                .addBytes(4 + getWrittenLength() + 1);
    }

    @Override
    public void describeInto(DescriptionOutput desc, Authorisation auth)
            throws IOException {
        writeTo(desc, auth);
    }

    @Override
    public void writeTo(DataOutput sink, Authorisation auth) throws IOException {
        auth.verify();

        /* Sanity check, to catch one of the more plausible misuses of this
           class */
        if (!isRewound()) {
            throw new IllegalStateException(
                    "A MarshalledDescription can only be read/unmarshalled once");
        }
        RV_ARRAY_KNOWLEDGE.writeFieldDescriptionTo(sink,
                getMarshalledNoncopiableObjects(), false);
        sink.writeInt(getWrittenLength());
        byte[] transferBuffer = new byte[getWrittenLength()];
        readFully(transferBuffer);
        sink.write(transferBuffer);
        sink.writeBoolean(isReadOnly());
    }

    @Override
    public void replaceWithReproduction(Class<MarshalledDescription> referentClass,
            ReadableDescription desc, Authorisation auth) throws IOException {
        auth.verify();

        /* We'll have to do this via reflection, so that we can write to
           private, final fields. The fields we have to write are:

           - marshalledNoncopiableObjects; read first
           - byteBuffer; length and contents read next
           - objectsCursor; constant 0
         */
        try {
            FIELD_MAP.get("marshalledNoncopiableObjects").set(this,
                    RV_ARRAY_KNOWLEDGE.reproduce(desc, false));
            int bbLength = desc.readInt();
            byte[] bbStorage = new byte[bbLength];
            desc.readFully(bbStorage);
            ByteBuffer bb = ByteBuffer.wrap(bbStorage);
            boolean setReadOnly = desc.readBoolean();
            if (setReadOnly) {
                bb = bb.asReadOnlyBuffer();
            }

            FIELD_MAP.get("byteBuffer").set(this, bb);
            FIELD_MAP.get("objectsCursor").set(this, 0);
        } catch (IllegalAccessException ex) {
            /* This shouldn't happen, because ClassKnowledge overrides any
               access restrictions for us. */
            throw new IOException(ex);
        }
    }

    @Override
    public Object invoke(long methodCode, Object[] methodArguments,
            Authorisation auth) throws Throwable {
        auth.verify();
        /* Because this standin is written by hand rather than being generated
           code, hardcoding the method codes isn't worthwhile. Just do it the
           slow way. */
        return new ReflectiveStandin<>(this).invoke(
                methodCode, methodArguments, auth);
    }

    @Override
    public MarshalledDescription getReferent(Authorisation auth) {
        auth.verify();
        return this;
    }

    /**
     * Factory for creating standins for MarshalledDescriptions.
     */
    static class Factory implements StandinFactory<MarshalledDescription> {

        @Override
        public Standin<MarshalledDescription> newFromDescription(
                ReadableDescription description)
                throws IOException, UnsupportedOperationException {
            ReferenceValue<?>[] rvArray
                    = RV_ARRAY_KNOWLEDGE.reproduce(description, false);
            int bbLength = description.readInt();
            byte[] bbStorage = new byte[bbLength];
            description.readFully(bbStorage);
            boolean setReadOnly = description.readBoolean();
            DataByteBuffer bb = new DataByteBuffer(bbStorage, setReadOnly);

            return new MarshalledDescriptionStandin(rvArray, bb, 0);
        }

        @Override
        public Standin<MarshalledDescription> wrapObject(
                MarshalledDescription t) throws UnsupportedOperationException {
            throw new UnsupportedOperationException(
                    "MarshalledDescriptionStandins cannot be indirect");
        }

        @Override
        public Standin<MarshalledDescription> standinFromLocationManager(
                LocationManager<MarshalledDescription> lm)
                throws UnsupportedOperationException {
            throw new UnsupportedOperationException(
                    "Cannot set storage for a Copiable standin");
        }
    }
}

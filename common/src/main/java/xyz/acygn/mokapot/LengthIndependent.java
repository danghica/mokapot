package xyz.acygn.mokapot;

import java.lang.reflect.InvocationTargetException;
import xyz.acygn.mokapot.markers.DistributedError;
import xyz.acygn.mokapot.skeletons.ArtificialWrapper;
import xyz.acygn.mokapot.skeletons.ProxyOrWrapper;
import xyz.acygn.mokapot.util.TypeSafe;

/**
 * Redefinitions of Java's primitive operations to treat long references and
 * short references the same way. Some of Java's most fundamental operations,
 * such as the <code>==</code> operator, are coded without the use of method
 * calls on their operands. This means that long references cannot transfer the
 * method call onto the original object, as there's no method call to transfer.
 * This class contains reimplementations of these operations that correctly
 * handle both long and short references.
 *
 * @author Alex Smith
 */
public class LengthIndependent {

    /**
     * Determines the actual class of the object a given reference references.
     * Note that this is only guaranteed to work correctly for objects created
     * either without using this package, or using this package's public API
     * only; objects that were used internally within this package (and
     * accessed, e.g., via reflection) may produce unexpected results.
     * <p>
     * When given an enum constant, this method returns the enum class that the
     * constant belongs to (not the singleton enum constant class that's used to
     * define the enum constant).
     *
     * @param <T> A declared class for the object. Can just be <code>?</code> or
     * <code>Object</code> to emulate the functionality of
     * <code>Object#getClass</code>.
     * @param ref A reference.
     * @return The actual class of the object referenced by <code>ref</code>.
     * @throws NullPointerException If <code>ref</code> is null
     * @see Object#getClass()
     */
    @SuppressWarnings("unchecked")
    public static <T> Class<? extends T> getActualClass(T ref)
            throws NullPointerException {
        if (ref instanceof ProxyOrWrapper) {
            /* Note that not only is this cast unchecked, it's not even valid in
               100% of situations; the situations in which it fails are when T
               is a standin class in its own right (in which case the function
               signature is impossible to respect). This clearly isn't a valid
               use of the function, though, and because standin classes are
               autogenerated they shouldn't be referenceable from manually
               written code. */
            @SuppressWarnings("unchecked")
            Class<? extends T> rv
                    = (Class<? extends T>) ((ProxyOrWrapper) ref).getReferentClass(null);
            return rv;
        }
        if (ref instanceof Enum) {
            Class<? extends T> rv = TypeSafe.getActualClass(ref);
            if (rv.getEnumConstants() != null) {
                return rv;
            } else if (Enum.class.isAssignableFrom(rv.getSuperclass())) {
                return (Class) rv.getSuperclass();
            }
        }
        //  System.out.println(ref);
        return TypeSafe.getActualClass(ref);
    }

    /**
     * Determines the actual class of the object a given reference references,
     * as seen by the distributed network code. In other words, this looks at
     * what an object "actually is" if it's imitating another object. However,
     * when given a standin or long reference, it'll still look at the target of
     * the reference.
     * <p>
     * This method is used to allow the distributed network code to send the
     * actual content of an object on the local system over the network, even if
     * the object in question is pretending to be a different sort of object.
     *
     * @param <T> A declared class for the object. Can just be <code>?</code> or
     * <code>Object</code> to emulate the functionality of
     * <code>Object#getClass</code>.
     * @param ref A reference.
     * @return The actual class of the object referenced by <code>ref</code>.
     * @throws NullPointerException If <code>ref</code> is null
     * @see Object#getClass()
     */
    static <T> Class<? extends T> getActualClassInternal(T ref)
            throws NullPointerException {
        if (ref instanceof ArtificialWrapper) {
            return TypeSafe.getActualClass(ref);
        }
        return getActualClass(ref);
    }

    /**
     * Returns whether the object referenced by a given reference extends the
     * given class or implements the given interface. This is similar to the
     * Java operator <code>instanceof</code>, but works on long references.
     *
     * @param o The object to check.
     * @param c The class or interface.
     * @return <code>true</code> if the object referenced by <code>o</code>
     * implements or extends <code>c</code>.
     */
    public static boolean isInstanceOf(Object o, Class<?> c) {
        return (o == null) ? false : c.isAssignableFrom(getActualClassInternal(o));
    }

    /**
     * Return if two references are the same. Not implemented at the moment.
     *
     * @param oOne A reference
     * @param oTwo A second reference
     * @return If the two corresponds to the same reference.
     */
    public static boolean areReferenceEqual(Object oOne, Object oTwo) {
        return oOne == oTwo;
    }

    /**
     * Returns the <code>Thread</code> object for the currently executing
     * thread. This method abstracts the notion of a "thread" across systems,
     * i.e. if you call this method, then call it again remotely via
     * <code>runRemotely()</code>, both calls will return the same object.
     *
     * @return The currently executing thread.
     */
    public static Thread currentThread() {
        try {
            return (Thread) Class.forName("xyz.acygn.mokapot.DistributedCommunicator")
                    .getDeclaredMethod("getCurrentThread", new Class<?>[0])
                    .invoke((Object) null, new Object[0]);
        } catch (ClassNotFoundException ex) {
            return Thread.currentThread();
        } catch (NoSuchMethodException | SecurityException
                | IllegalAccessException | InvocationTargetException ex) {
            throw new DistributedError(ex, "LengthIndependent#currentThread");
        }
    }

    /**
     * Inaccessible constructor. This is a utility class that is not meant to be
     * instantiated, and serves only to provide a namespace for the methods in
     * it.
     */
    private LengthIndependent() {
    }
}
